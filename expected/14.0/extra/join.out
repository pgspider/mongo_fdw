-- Before running this file User must create database join_regress
-- databases on MongoDB with all permission for
-- user with password and ran mongodb_init.sh
-- file to load collections.
\set ECHO none
SET datestyle TO ISO;
--Testcase 1:
CREATE EXTENSION IF NOT EXISTS mongo_fdw;
--Testcase 2:
CREATE SERVER mongo_server FOREIGN DATA WRAPPER mongo_fdw
  OPTIONS (address :MONGO_HOST, port :MONGO_PORT);
--Testcase 3:
CREATE USER MAPPING FOR public SERVER mongo_server;
--
-- JOIN
-- Test JOIN clauses
--
--Testcase 4:
CREATE FOREIGN TABLE J1_TBL (_id int4, i int, j int, t text)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'J1_TBL');
--Testcase 5:
CREATE FOREIGN TABLE J2_TBL (_id int4, i int, k int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'J2_TBL');
-- useful in some tests below
--Testcase 6:
create temp table onerow();
--Testcase 7:
insert into onerow default values;
analyze onerow;
--
-- CORRELATION NAMES
-- Make sure that table/column aliases are supported
-- before diving into more complex join syntax.
--
--Testcase 8:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL AS tx;
                                                                                      QUERY PLAN                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.j1_tbl tx  (cost=0.00..0.00 rows=1000 width=44)
   Output: _id, i, j, t
   Foreign Namespace: join_regress.J1_TBL
   Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 9:
SELECT *
  FROM J1_TBL AS tx;
 _id | i | j |   t   
-----+---+---+-------
   1 | 1 | 4 | one
   2 | 2 | 3 | two
   3 | 3 | 2 | three
   4 | 4 | 1 | for
   5 | 5 | 0 | five
   6 | 6 | 6 | six
   7 | 7 | 7 | seven
   8 | 8 | 8 | eight
   9 | 0 |   | zero
  10 |   |   | null
  11 |   | 0 | zero
(11 rows)

--Testcase 10:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL tx;
                                                                                      QUERY PLAN                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.j1_tbl tx  (cost=0.00..0.00 rows=1000 width=44)
   Output: _id, i, j, t
   Foreign Namespace: join_regress.J1_TBL
   Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 11:
SELECT *
  FROM J1_TBL tx;
 _id | i | j |   t   
-----+---+---+-------
   1 | 1 | 4 | one
   2 | 2 | 3 | two
   3 | 3 | 2 | three
   4 | 4 | 1 | for
   5 | 5 | 0 | five
   6 | 6 | 6 | six
   7 | 7 | 7 | seven
   8 | 8 | 8 | eight
   9 | 0 |   | zero
  10 |   |   | null
  11 |   | 0 | zero
(11 rows)

--Testcase 12:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL AS t1 (id, a, b, c);
                                                                                      QUERY PLAN                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1000 width=44)
   Output: id, a, b, c
   Foreign Namespace: join_regress.J1_TBL
   Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 13:
SELECT *
  FROM J1_TBL AS t1 (id, a, b, c);
 id | a | b |   c   
----+---+---+-------
  1 | 1 | 4 | one
  2 | 2 | 3 | two
  3 | 3 | 2 | three
  4 | 4 | 1 | for
  5 | 5 | 0 | five
  6 | 6 | 6 | six
  7 | 7 | 7 | seven
  8 | 8 | 8 | eight
  9 | 0 |   | zero
 10 |   |   | null
 11 |   | 0 | zero
(11 rows)

--Testcase 14:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL t1 (id, a, b, c);
                                                                                      QUERY PLAN                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1000 width=44)
   Output: id, a, b, c
   Foreign Namespace: join_regress.J1_TBL
   Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 15:
SELECT *
  FROM J1_TBL t1 (id, a, b, c);
 id | a | b |   c   
----+---+---+-------
  1 | 1 | 4 | one
  2 | 2 | 3 | two
  3 | 3 | 2 | three
  4 | 4 | 1 | for
  5 | 5 | 0 | five
  6 | 6 | 6 | six
  7 | 7 | 7 | seven
  8 | 8 | 8 | eight
  9 | 0 |   | zero
 10 |   |   | null
 11 |   | 0 | zero
(11 rows)

--Testcase 16:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL t1 (id1, a, b, c), J2_TBL t2 (id2, d, e);
                                                                                         QUERY PLAN                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.00..10000.00 rows=1000000 width=56)
   Output: t1.id1, t1.a, t1.b, t1.c, t2.id2, t2.d, t2.e
   ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1000 width=44)
         Output: t1.id1, t1.a, t1.b, t1.c
         Foreign Namespace: join_regress.J1_TBL
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Foreign Scan on public.j2_tbl t2  (cost=0.00..0.00 rows=1000 width=12)
         Output: t2.id2, t2.d, t2.e
         Foreign Namespace: join_regress.J2_TBL
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(10 rows)

--Testcase 17:
SELECT *
  FROM J1_TBL t1 (id1, a, b, c), J2_TBL t2 (id2, d, e);
 id1 | a | b |   c   | id2 | d | e  
-----+---+---+-------+-----+---+----
   1 | 1 | 4 | one   |   1 | 1 | -1
   1 | 1 | 4 | one   |   2 | 2 |  2
   1 | 1 | 4 | one   |   3 | 3 | -3
   1 | 1 | 4 | one   |   4 | 2 |  4
   1 | 1 | 4 | one   |   5 | 5 | -5
   1 | 1 | 4 | one   |   6 | 5 | -5
   1 | 1 | 4 | one   |   7 | 0 |   
   1 | 1 | 4 | one   |   8 |   |   
   1 | 1 | 4 | one   |   9 |   |  0
   2 | 2 | 3 | two   |   1 | 1 | -1
   2 | 2 | 3 | two   |   2 | 2 |  2
   2 | 2 | 3 | two   |   3 | 3 | -3
   2 | 2 | 3 | two   |   4 | 2 |  4
   2 | 2 | 3 | two   |   5 | 5 | -5
   2 | 2 | 3 | two   |   6 | 5 | -5
   2 | 2 | 3 | two   |   7 | 0 |   
   2 | 2 | 3 | two   |   8 |   |   
   2 | 2 | 3 | two   |   9 |   |  0
   3 | 3 | 2 | three |   1 | 1 | -1
   3 | 3 | 2 | three |   2 | 2 |  2
   3 | 3 | 2 | three |   3 | 3 | -3
   3 | 3 | 2 | three |   4 | 2 |  4
   3 | 3 | 2 | three |   5 | 5 | -5
   3 | 3 | 2 | three |   6 | 5 | -5
   3 | 3 | 2 | three |   7 | 0 |   
   3 | 3 | 2 | three |   8 |   |   
   3 | 3 | 2 | three |   9 |   |  0
   4 | 4 | 1 | for   |   1 | 1 | -1
   4 | 4 | 1 | for   |   2 | 2 |  2
   4 | 4 | 1 | for   |   3 | 3 | -3
   4 | 4 | 1 | for   |   4 | 2 |  4
   4 | 4 | 1 | for   |   5 | 5 | -5
   4 | 4 | 1 | for   |   6 | 5 | -5
   4 | 4 | 1 | for   |   7 | 0 |   
   4 | 4 | 1 | for   |   8 |   |   
   4 | 4 | 1 | for   |   9 |   |  0
   5 | 5 | 0 | five  |   1 | 1 | -1
   5 | 5 | 0 | five  |   2 | 2 |  2
   5 | 5 | 0 | five  |   3 | 3 | -3
   5 | 5 | 0 | five  |   4 | 2 |  4
   5 | 5 | 0 | five  |   5 | 5 | -5
   5 | 5 | 0 | five  |   6 | 5 | -5
   5 | 5 | 0 | five  |   7 | 0 |   
   5 | 5 | 0 | five  |   8 |   |   
   5 | 5 | 0 | five  |   9 |   |  0
   6 | 6 | 6 | six   |   1 | 1 | -1
   6 | 6 | 6 | six   |   2 | 2 |  2
   6 | 6 | 6 | six   |   3 | 3 | -3
   6 | 6 | 6 | six   |   4 | 2 |  4
   6 | 6 | 6 | six   |   5 | 5 | -5
   6 | 6 | 6 | six   |   6 | 5 | -5
   6 | 6 | 6 | six   |   7 | 0 |   
   6 | 6 | 6 | six   |   8 |   |   
   6 | 6 | 6 | six   |   9 |   |  0
   7 | 7 | 7 | seven |   1 | 1 | -1
   7 | 7 | 7 | seven |   2 | 2 |  2
   7 | 7 | 7 | seven |   3 | 3 | -3
   7 | 7 | 7 | seven |   4 | 2 |  4
   7 | 7 | 7 | seven |   5 | 5 | -5
   7 | 7 | 7 | seven |   6 | 5 | -5
   7 | 7 | 7 | seven |   7 | 0 |   
   7 | 7 | 7 | seven |   8 |   |   
   7 | 7 | 7 | seven |   9 |   |  0
   8 | 8 | 8 | eight |   1 | 1 | -1
   8 | 8 | 8 | eight |   2 | 2 |  2
   8 | 8 | 8 | eight |   3 | 3 | -3
   8 | 8 | 8 | eight |   4 | 2 |  4
   8 | 8 | 8 | eight |   5 | 5 | -5
   8 | 8 | 8 | eight |   6 | 5 | -5
   8 | 8 | 8 | eight |   7 | 0 |   
   8 | 8 | 8 | eight |   8 |   |   
   8 | 8 | 8 | eight |   9 |   |  0
   9 | 0 |   | zero  |   1 | 1 | -1
   9 | 0 |   | zero  |   2 | 2 |  2
   9 | 0 |   | zero  |   3 | 3 | -3
   9 | 0 |   | zero  |   4 | 2 |  4
   9 | 0 |   | zero  |   5 | 5 | -5
   9 | 0 |   | zero  |   6 | 5 | -5
   9 | 0 |   | zero  |   7 | 0 |   
   9 | 0 |   | zero  |   8 |   |   
   9 | 0 |   | zero  |   9 |   |  0
  10 |   |   | null  |   1 | 1 | -1
  10 |   |   | null  |   2 | 2 |  2
  10 |   |   | null  |   3 | 3 | -3
  10 |   |   | null  |   4 | 2 |  4
  10 |   |   | null  |   5 | 5 | -5
  10 |   |   | null  |   6 | 5 | -5
  10 |   |   | null  |   7 | 0 |   
  10 |   |   | null  |   8 |   |   
  10 |   |   | null  |   9 |   |  0
  11 |   | 0 | zero  |   1 | 1 | -1
  11 |   | 0 | zero  |   2 | 2 |  2
  11 |   | 0 | zero  |   3 | 3 | -3
  11 |   | 0 | zero  |   4 | 2 |  4
  11 |   | 0 | zero  |   5 | 5 | -5
  11 |   | 0 | zero  |   6 | 5 | -5
  11 |   | 0 | zero  |   7 | 0 |   
  11 |   | 0 | zero  |   8 |   |   
  11 |   | 0 | zero  |   9 |   |  0
(99 rows)

--Testcase 18:
EXPLAIN VERBOSE SELECT t1.a, t2.e
  FROM J1_TBL t1 (id1, a, b, c), J2_TBL t2 (id2, d, e)
  WHERE t1.a = t2.d;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=99.66..179.66 rows=5000 width=8)
   Output: t1.a, t2.e
   Merge Cond: (t1.a = t2.d)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=4)
         Output: t1.a
         Sort Key: t1.a
         ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1000 width=4)
               Output: t1.a
               Foreign Namespace: join_regress.J1_TBL
               Query document: { "pipeline" : [ { "$project" : { "i" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=8)
         Output: t2.e, t2.d
         Sort Key: t2.d
         ->  Foreign Scan on public.j2_tbl t2  (cost=0.00..0.00 rows=1000 width=8)
               Output: t2.e, t2.d
               Foreign Namespace: join_regress.J2_TBL
               Query document: { "pipeline" : [ { "$project" : { "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 19:
SELECT t1.a, t2.e
  FROM J1_TBL t1 (id1, a, b, c), J2_TBL t2 (id2, d, e)
  WHERE t1.a = t2.d;
 a | e  
---+----
 0 |   
 1 | -1
 2 |  2
 2 |  4
 3 | -3
 5 | -5
 5 | -5
(7 rows)

--
-- CROSS JOIN
-- Qualifications are not allowed on cross joins,
-- which degenerate into a standard unqualified inner join.
--
--Testcase 20:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL CROSS JOIN J2_TBL;
                                                                                         QUERY PLAN                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.00..10000.00 rows=1000000 width=56)
   Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.i, j2_tbl.k
   ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1000 width=44)
         Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t
         Foreign Namespace: join_regress.J1_TBL
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1000 width=12)
         Output: j2_tbl._id, j2_tbl.i, j2_tbl.k
         Foreign Namespace: join_regress.J2_TBL
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(10 rows)

--Testcase 21:
SELECT *
  FROM J1_TBL CROSS JOIN J2_TBL;
 _id | i | j |   t   | _id | i | k  
-----+---+---+-------+-----+---+----
   1 | 1 | 4 | one   |   1 | 1 | -1
   1 | 1 | 4 | one   |   2 | 2 |  2
   1 | 1 | 4 | one   |   3 | 3 | -3
   1 | 1 | 4 | one   |   4 | 2 |  4
   1 | 1 | 4 | one   |   5 | 5 | -5
   1 | 1 | 4 | one   |   6 | 5 | -5
   1 | 1 | 4 | one   |   7 | 0 |   
   1 | 1 | 4 | one   |   8 |   |   
   1 | 1 | 4 | one   |   9 |   |  0
   2 | 2 | 3 | two   |   1 | 1 | -1
   2 | 2 | 3 | two   |   2 | 2 |  2
   2 | 2 | 3 | two   |   3 | 3 | -3
   2 | 2 | 3 | two   |   4 | 2 |  4
   2 | 2 | 3 | two   |   5 | 5 | -5
   2 | 2 | 3 | two   |   6 | 5 | -5
   2 | 2 | 3 | two   |   7 | 0 |   
   2 | 2 | 3 | two   |   8 |   |   
   2 | 2 | 3 | two   |   9 |   |  0
   3 | 3 | 2 | three |   1 | 1 | -1
   3 | 3 | 2 | three |   2 | 2 |  2
   3 | 3 | 2 | three |   3 | 3 | -3
   3 | 3 | 2 | three |   4 | 2 |  4
   3 | 3 | 2 | three |   5 | 5 | -5
   3 | 3 | 2 | three |   6 | 5 | -5
   3 | 3 | 2 | three |   7 | 0 |   
   3 | 3 | 2 | three |   8 |   |   
   3 | 3 | 2 | three |   9 |   |  0
   4 | 4 | 1 | for   |   1 | 1 | -1
   4 | 4 | 1 | for   |   2 | 2 |  2
   4 | 4 | 1 | for   |   3 | 3 | -3
   4 | 4 | 1 | for   |   4 | 2 |  4
   4 | 4 | 1 | for   |   5 | 5 | -5
   4 | 4 | 1 | for   |   6 | 5 | -5
   4 | 4 | 1 | for   |   7 | 0 |   
   4 | 4 | 1 | for   |   8 |   |   
   4 | 4 | 1 | for   |   9 |   |  0
   5 | 5 | 0 | five  |   1 | 1 | -1
   5 | 5 | 0 | five  |   2 | 2 |  2
   5 | 5 | 0 | five  |   3 | 3 | -3
   5 | 5 | 0 | five  |   4 | 2 |  4
   5 | 5 | 0 | five  |   5 | 5 | -5
   5 | 5 | 0 | five  |   6 | 5 | -5
   5 | 5 | 0 | five  |   7 | 0 |   
   5 | 5 | 0 | five  |   8 |   |   
   5 | 5 | 0 | five  |   9 |   |  0
   6 | 6 | 6 | six   |   1 | 1 | -1
   6 | 6 | 6 | six   |   2 | 2 |  2
   6 | 6 | 6 | six   |   3 | 3 | -3
   6 | 6 | 6 | six   |   4 | 2 |  4
   6 | 6 | 6 | six   |   5 | 5 | -5
   6 | 6 | 6 | six   |   6 | 5 | -5
   6 | 6 | 6 | six   |   7 | 0 |   
   6 | 6 | 6 | six   |   8 |   |   
   6 | 6 | 6 | six   |   9 |   |  0
   7 | 7 | 7 | seven |   1 | 1 | -1
   7 | 7 | 7 | seven |   2 | 2 |  2
   7 | 7 | 7 | seven |   3 | 3 | -3
   7 | 7 | 7 | seven |   4 | 2 |  4
   7 | 7 | 7 | seven |   5 | 5 | -5
   7 | 7 | 7 | seven |   6 | 5 | -5
   7 | 7 | 7 | seven |   7 | 0 |   
   7 | 7 | 7 | seven |   8 |   |   
   7 | 7 | 7 | seven |   9 |   |  0
   8 | 8 | 8 | eight |   1 | 1 | -1
   8 | 8 | 8 | eight |   2 | 2 |  2
   8 | 8 | 8 | eight |   3 | 3 | -3
   8 | 8 | 8 | eight |   4 | 2 |  4
   8 | 8 | 8 | eight |   5 | 5 | -5
   8 | 8 | 8 | eight |   6 | 5 | -5
   8 | 8 | 8 | eight |   7 | 0 |   
   8 | 8 | 8 | eight |   8 |   |   
   8 | 8 | 8 | eight |   9 |   |  0
   9 | 0 |   | zero  |   1 | 1 | -1
   9 | 0 |   | zero  |   2 | 2 |  2
   9 | 0 |   | zero  |   3 | 3 | -3
   9 | 0 |   | zero  |   4 | 2 |  4
   9 | 0 |   | zero  |   5 | 5 | -5
   9 | 0 |   | zero  |   6 | 5 | -5
   9 | 0 |   | zero  |   7 | 0 |   
   9 | 0 |   | zero  |   8 |   |   
   9 | 0 |   | zero  |   9 |   |  0
  10 |   |   | null  |   1 | 1 | -1
  10 |   |   | null  |   2 | 2 |  2
  10 |   |   | null  |   3 | 3 | -3
  10 |   |   | null  |   4 | 2 |  4
  10 |   |   | null  |   5 | 5 | -5
  10 |   |   | null  |   6 | 5 | -5
  10 |   |   | null  |   7 | 0 |   
  10 |   |   | null  |   8 |   |   
  10 |   |   | null  |   9 |   |  0
  11 |   | 0 | zero  |   1 | 1 | -1
  11 |   | 0 | zero  |   2 | 2 |  2
  11 |   | 0 | zero  |   3 | 3 | -3
  11 |   | 0 | zero  |   4 | 2 |  4
  11 |   | 0 | zero  |   5 | 5 | -5
  11 |   | 0 | zero  |   6 | 5 | -5
  11 |   | 0 | zero  |   7 | 0 |   
  11 |   | 0 | zero  |   8 |   |   
  11 |   | 0 | zero  |   9 |   |  0
(99 rows)

-- ambiguous column
--Testcase 22:
EXPLAIN VERBOSE SELECT i, k, t
  FROM J1_TBL CROSS JOIN J2_TBL;
ERROR:  column reference "i" is ambiguous
LINE 1: EXPLAIN VERBOSE SELECT i, k, t
                               ^
--Testcase 23:
SELECT i, k, t
  FROM J1_TBL CROSS JOIN J2_TBL;
ERROR:  column reference "i" is ambiguous
LINE 1: SELECT i, k, t
               ^
-- resolve previous ambiguity by specifying the table name
--Testcase 24:
EXPLAIN VERBOSE SELECT t1.i, k, t
  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.00..10000.00 rows=1000000 width=40)
   Output: t1.i, t2.k, t1.t
   ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1000 width=36)
         Output: t1._id, t1.i, t1.j, t1.t
         Foreign Namespace: join_regress.J1_TBL
         Query document: { "pipeline" : [ { "$project" : { "i" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Foreign Scan on public.j2_tbl t2  (cost=0.00..0.00 rows=1000 width=4)
         Output: t2._id, t2.i, t2.k
         Foreign Namespace: join_regress.J2_TBL
         Query document: { "pipeline" : [ { "$project" : { "k" : { "$numberInt" : "1" } } } ] }
(10 rows)

--Testcase 25:
SELECT t1.i, k, t
  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;
 i | k  |   t   
---+----+-------
 1 | -1 | one
 1 |  2 | one
 1 | -3 | one
 1 |  4 | one
 1 | -5 | one
 1 | -5 | one
 1 |    | one
 1 |    | one
 1 |  0 | one
 2 | -1 | two
 2 |  2 | two
 2 | -3 | two
 2 |  4 | two
 2 | -5 | two
 2 | -5 | two
 2 |    | two
 2 |    | two
 2 |  0 | two
 3 | -1 | three
 3 |  2 | three
 3 | -3 | three
 3 |  4 | three
 3 | -5 | three
 3 | -5 | three
 3 |    | three
 3 |    | three
 3 |  0 | three
 4 | -1 | for
 4 |  2 | for
 4 | -3 | for
 4 |  4 | for
 4 | -5 | for
 4 | -5 | for
 4 |    | for
 4 |    | for
 4 |  0 | for
 5 | -1 | five
 5 |  2 | five
 5 | -3 | five
 5 |  4 | five
 5 | -5 | five
 5 | -5 | five
 5 |    | five
 5 |    | five
 5 |  0 | five
 6 | -1 | six
 6 |  2 | six
 6 | -3 | six
 6 |  4 | six
 6 | -5 | six
 6 | -5 | six
 6 |    | six
 6 |    | six
 6 |  0 | six
 7 | -1 | seven
 7 |  2 | seven
 7 | -3 | seven
 7 |  4 | seven
 7 | -5 | seven
 7 | -5 | seven
 7 |    | seven
 7 |    | seven
 7 |  0 | seven
 8 | -1 | eight
 8 |  2 | eight
 8 | -3 | eight
 8 |  4 | eight
 8 | -5 | eight
 8 | -5 | eight
 8 |    | eight
 8 |    | eight
 8 |  0 | eight
 0 | -1 | zero
 0 |  2 | zero
 0 | -3 | zero
 0 |  4 | zero
 0 | -5 | zero
 0 | -5 | zero
 0 |    | zero
 0 |    | zero
 0 |  0 | zero
   | -1 | null
   |  2 | null
   | -3 | null
   |  4 | null
   | -5 | null
   | -5 | null
   |    | null
   |    | null
   |  0 | null
   | -1 | zero
   |  2 | zero
   | -3 | zero
   |  4 | zero
   | -5 | zero
   | -5 | zero
   |    | zero
   |    | zero
   |  0 | zero
(99 rows)

--Testcase 26:
EXPLAIN VERBOSE SELECT ii, tt, kk
  FROM (J1_TBL CROSS JOIN J2_TBL)
    AS tx (idd1, ii, jj, tt, idd2, ii2, kk);
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.00..10000.00 rows=1000000 width=40)
   Output: j1_tbl.i, j1_tbl.t, j2_tbl.k
   ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1000 width=36)
         Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t
         Foreign Namespace: join_regress.J1_TBL
         Query document: { "pipeline" : [ { "$project" : { "i" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1000 width=4)
         Output: j2_tbl._id, j2_tbl.i, j2_tbl.k
         Foreign Namespace: join_regress.J2_TBL
         Query document: { "pipeline" : [ { "$project" : { "k" : { "$numberInt" : "1" } } } ] }
(10 rows)

--Testcase 27:
SELECT ii, tt, kk
  FROM (J1_TBL CROSS JOIN J2_TBL)
    AS tx (idd1, ii, jj, tt, idd2, ii2, kk);
 ii |  tt   | kk 
----+-------+----
  1 | one   | -1
  1 | one   |  2
  1 | one   | -3
  1 | one   |  4
  1 | one   | -5
  1 | one   | -5
  1 | one   |   
  1 | one   |   
  1 | one   |  0
  2 | two   | -1
  2 | two   |  2
  2 | two   | -3
  2 | two   |  4
  2 | two   | -5
  2 | two   | -5
  2 | two   |   
  2 | two   |   
  2 | two   |  0
  3 | three | -1
  3 | three |  2
  3 | three | -3
  3 | three |  4
  3 | three | -5
  3 | three | -5
  3 | three |   
  3 | three |   
  3 | three |  0
  4 | for   | -1
  4 | for   |  2
  4 | for   | -3
  4 | for   |  4
  4 | for   | -5
  4 | for   | -5
  4 | for   |   
  4 | for   |   
  4 | for   |  0
  5 | five  | -1
  5 | five  |  2
  5 | five  | -3
  5 | five  |  4
  5 | five  | -5
  5 | five  | -5
  5 | five  |   
  5 | five  |   
  5 | five  |  0
  6 | six   | -1
  6 | six   |  2
  6 | six   | -3
  6 | six   |  4
  6 | six   | -5
  6 | six   | -5
  6 | six   |   
  6 | six   |   
  6 | six   |  0
  7 | seven | -1
  7 | seven |  2
  7 | seven | -3
  7 | seven |  4
  7 | seven | -5
  7 | seven | -5
  7 | seven |   
  7 | seven |   
  7 | seven |  0
  8 | eight | -1
  8 | eight |  2
  8 | eight | -3
  8 | eight |  4
  8 | eight | -5
  8 | eight | -5
  8 | eight |   
  8 | eight |   
  8 | eight |  0
  0 | zero  | -1
  0 | zero  |  2
  0 | zero  | -3
  0 | zero  |  4
  0 | zero  | -5
  0 | zero  | -5
  0 | zero  |   
  0 | zero  |   
  0 | zero  |  0
    | null  | -1
    | null  |  2
    | null  | -3
    | null  |  4
    | null  | -5
    | null  | -5
    | null  |   
    | null  |   
    | null  |  0
    | zero  | -1
    | zero  |  2
    | zero  | -3
    | zero  |  4
    | zero  | -5
    | zero  | -5
    | zero  |   
    | zero  |   
    | zero  |  0
(99 rows)

--Testcase 28:
EXPLAIN VERBOSE SELECT tx.ii, tx.jj, tx.kk
  FROM (J1_TBL t1 (id1, a, b, c) CROSS JOIN J2_TBL t2 (id2, d, e))
    AS tx (idd1, ii, jj, tt, idd2, ii2, kk);
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.00..10000.00 rows=1000000 width=12)
   Output: t1.a, t1.b, t2.e
   ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1000 width=8)
         Output: t1.id1, t1.a, t1.b, t1.c
         Foreign Namespace: join_regress.J1_TBL
         Query document: { "pipeline" : [ { "$project" : { "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" } } } ] }
   ->  Foreign Scan on public.j2_tbl t2  (cost=0.00..0.00 rows=1000 width=4)
         Output: t2.id2, t2.d, t2.e
         Foreign Namespace: join_regress.J2_TBL
         Query document: { "pipeline" : [ { "$project" : { "k" : { "$numberInt" : "1" } } } ] }
(10 rows)

--Testcase 29:
SELECT tx.ii, tx.jj, tx.kk
  FROM (J1_TBL t1 (id1, a, b, c) CROSS JOIN J2_TBL t2 (id2, d, e))
    AS tx (idd1, ii, jj, tt, idd2, ii2, kk);
 ii | jj | kk 
----+----+----
  1 |  4 | -1
  1 |  4 |  2
  1 |  4 | -3
  1 |  4 |  4
  1 |  4 | -5
  1 |  4 | -5
  1 |  4 |   
  1 |  4 |   
  1 |  4 |  0
  2 |  3 | -1
  2 |  3 |  2
  2 |  3 | -3
  2 |  3 |  4
  2 |  3 | -5
  2 |  3 | -5
  2 |  3 |   
  2 |  3 |   
  2 |  3 |  0
  3 |  2 | -1
  3 |  2 |  2
  3 |  2 | -3
  3 |  2 |  4
  3 |  2 | -5
  3 |  2 | -5
  3 |  2 |   
  3 |  2 |   
  3 |  2 |  0
  4 |  1 | -1
  4 |  1 |  2
  4 |  1 | -3
  4 |  1 |  4
  4 |  1 | -5
  4 |  1 | -5
  4 |  1 |   
  4 |  1 |   
  4 |  1 |  0
  5 |  0 | -1
  5 |  0 |  2
  5 |  0 | -3
  5 |  0 |  4
  5 |  0 | -5
  5 |  0 | -5
  5 |  0 |   
  5 |  0 |   
  5 |  0 |  0
  6 |  6 | -1
  6 |  6 |  2
  6 |  6 | -3
  6 |  6 |  4
  6 |  6 | -5
  6 |  6 | -5
  6 |  6 |   
  6 |  6 |   
  6 |  6 |  0
  7 |  7 | -1
  7 |  7 |  2
  7 |  7 | -3
  7 |  7 |  4
  7 |  7 | -5
  7 |  7 | -5
  7 |  7 |   
  7 |  7 |   
  7 |  7 |  0
  8 |  8 | -1
  8 |  8 |  2
  8 |  8 | -3
  8 |  8 |  4
  8 |  8 | -5
  8 |  8 | -5
  8 |  8 |   
  8 |  8 |   
  8 |  8 |  0
  0 |    | -1
  0 |    |  2
  0 |    | -3
  0 |    |  4
  0 |    | -5
  0 |    | -5
  0 |    |   
  0 |    |   
  0 |    |  0
    |    | -1
    |    |  2
    |    | -3
    |    |  4
    |    | -5
    |    | -5
    |    |   
    |    |   
    |    |  0
    |  0 | -1
    |  0 |  2
    |  0 | -3
    |  0 |  4
    |  0 | -5
    |  0 | -5
    |  0 |   
    |  0 |   
    |  0 |  0
(99 rows)

--Testcase 30:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.00..10010000.00 rows=1000000000 width=68)
   Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t, a._id, a.i, a.k, b._id, b.i, b.k
   ->  Nested Loop  (cost=0.00..10000.00 rows=1000000 width=56)
         Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t, a._id, a.i, a.k
         ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1000 width=44)
               Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t
               Foreign Namespace: join_regress.J1_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
         ->  Foreign Scan on public.j2_tbl a  (cost=0.00..0.00 rows=1000 width=12)
               Output: a._id, a.i, a.k
               Foreign Namespace: join_regress.J2_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
   ->  Foreign Scan on public.j2_tbl b  (cost=0.00..0.00 rows=1000 width=12)
         Output: b._id, b.i, b.k
         Foreign Namespace: join_regress.J2_TBL
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(16 rows)

--Testcase 31:
SELECT *
  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;
 _id | i | j |   t   | _id | i | k  | _id | i | k  
-----+---+---+-------+-----+---+----+-----+---+----
   1 | 1 | 4 | one   |   1 | 1 | -1 |   1 | 1 | -1
   1 | 1 | 4 | one   |   1 | 1 | -1 |   2 | 2 |  2
   1 | 1 | 4 | one   |   1 | 1 | -1 |   3 | 3 | -3
   1 | 1 | 4 | one   |   1 | 1 | -1 |   4 | 2 |  4
   1 | 1 | 4 | one   |   1 | 1 | -1 |   5 | 5 | -5
   1 | 1 | 4 | one   |   1 | 1 | -1 |   6 | 5 | -5
   1 | 1 | 4 | one   |   1 | 1 | -1 |   7 | 0 |   
   1 | 1 | 4 | one   |   1 | 1 | -1 |   8 |   |   
   1 | 1 | 4 | one   |   1 | 1 | -1 |   9 |   |  0
   1 | 1 | 4 | one   |   2 | 2 |  2 |   1 | 1 | -1
   1 | 1 | 4 | one   |   2 | 2 |  2 |   2 | 2 |  2
   1 | 1 | 4 | one   |   2 | 2 |  2 |   3 | 3 | -3
   1 | 1 | 4 | one   |   2 | 2 |  2 |   4 | 2 |  4
   1 | 1 | 4 | one   |   2 | 2 |  2 |   5 | 5 | -5
   1 | 1 | 4 | one   |   2 | 2 |  2 |   6 | 5 | -5
   1 | 1 | 4 | one   |   2 | 2 |  2 |   7 | 0 |   
   1 | 1 | 4 | one   |   2 | 2 |  2 |   8 |   |   
   1 | 1 | 4 | one   |   2 | 2 |  2 |   9 |   |  0
   1 | 1 | 4 | one   |   3 | 3 | -3 |   1 | 1 | -1
   1 | 1 | 4 | one   |   3 | 3 | -3 |   2 | 2 |  2
   1 | 1 | 4 | one   |   3 | 3 | -3 |   3 | 3 | -3
   1 | 1 | 4 | one   |   3 | 3 | -3 |   4 | 2 |  4
   1 | 1 | 4 | one   |   3 | 3 | -3 |   5 | 5 | -5
   1 | 1 | 4 | one   |   3 | 3 | -3 |   6 | 5 | -5
   1 | 1 | 4 | one   |   3 | 3 | -3 |   7 | 0 |   
   1 | 1 | 4 | one   |   3 | 3 | -3 |   8 |   |   
   1 | 1 | 4 | one   |   3 | 3 | -3 |   9 |   |  0
   1 | 1 | 4 | one   |   4 | 2 |  4 |   1 | 1 | -1
   1 | 1 | 4 | one   |   4 | 2 |  4 |   2 | 2 |  2
   1 | 1 | 4 | one   |   4 | 2 |  4 |   3 | 3 | -3
   1 | 1 | 4 | one   |   4 | 2 |  4 |   4 | 2 |  4
   1 | 1 | 4 | one   |   4 | 2 |  4 |   5 | 5 | -5
   1 | 1 | 4 | one   |   4 | 2 |  4 |   6 | 5 | -5
   1 | 1 | 4 | one   |   4 | 2 |  4 |   7 | 0 |   
   1 | 1 | 4 | one   |   4 | 2 |  4 |   8 |   |   
   1 | 1 | 4 | one   |   4 | 2 |  4 |   9 |   |  0
   1 | 1 | 4 | one   |   5 | 5 | -5 |   1 | 1 | -1
   1 | 1 | 4 | one   |   5 | 5 | -5 |   2 | 2 |  2
   1 | 1 | 4 | one   |   5 | 5 | -5 |   3 | 3 | -3
   1 | 1 | 4 | one   |   5 | 5 | -5 |   4 | 2 |  4
   1 | 1 | 4 | one   |   5 | 5 | -5 |   5 | 5 | -5
   1 | 1 | 4 | one   |   5 | 5 | -5 |   6 | 5 | -5
   1 | 1 | 4 | one   |   5 | 5 | -5 |   7 | 0 |   
   1 | 1 | 4 | one   |   5 | 5 | -5 |   8 |   |   
   1 | 1 | 4 | one   |   5 | 5 | -5 |   9 |   |  0
   1 | 1 | 4 | one   |   6 | 5 | -5 |   1 | 1 | -1
   1 | 1 | 4 | one   |   6 | 5 | -5 |   2 | 2 |  2
   1 | 1 | 4 | one   |   6 | 5 | -5 |   3 | 3 | -3
   1 | 1 | 4 | one   |   6 | 5 | -5 |   4 | 2 |  4
   1 | 1 | 4 | one   |   6 | 5 | -5 |   5 | 5 | -5
   1 | 1 | 4 | one   |   6 | 5 | -5 |   6 | 5 | -5
   1 | 1 | 4 | one   |   6 | 5 | -5 |   7 | 0 |   
   1 | 1 | 4 | one   |   6 | 5 | -5 |   8 |   |   
   1 | 1 | 4 | one   |   6 | 5 | -5 |   9 |   |  0
   1 | 1 | 4 | one   |   7 | 0 |    |   1 | 1 | -1
   1 | 1 | 4 | one   |   7 | 0 |    |   2 | 2 |  2
   1 | 1 | 4 | one   |   7 | 0 |    |   3 | 3 | -3
   1 | 1 | 4 | one   |   7 | 0 |    |   4 | 2 |  4
   1 | 1 | 4 | one   |   7 | 0 |    |   5 | 5 | -5
   1 | 1 | 4 | one   |   7 | 0 |    |   6 | 5 | -5
   1 | 1 | 4 | one   |   7 | 0 |    |   7 | 0 |   
   1 | 1 | 4 | one   |   7 | 0 |    |   8 |   |   
   1 | 1 | 4 | one   |   7 | 0 |    |   9 |   |  0
   1 | 1 | 4 | one   |   8 |   |    |   1 | 1 | -1
   1 | 1 | 4 | one   |   8 |   |    |   2 | 2 |  2
   1 | 1 | 4 | one   |   8 |   |    |   3 | 3 | -3
   1 | 1 | 4 | one   |   8 |   |    |   4 | 2 |  4
   1 | 1 | 4 | one   |   8 |   |    |   5 | 5 | -5
   1 | 1 | 4 | one   |   8 |   |    |   6 | 5 | -5
   1 | 1 | 4 | one   |   8 |   |    |   7 | 0 |   
   1 | 1 | 4 | one   |   8 |   |    |   8 |   |   
   1 | 1 | 4 | one   |   8 |   |    |   9 |   |  0
   1 | 1 | 4 | one   |   9 |   |  0 |   1 | 1 | -1
   1 | 1 | 4 | one   |   9 |   |  0 |   2 | 2 |  2
   1 | 1 | 4 | one   |   9 |   |  0 |   3 | 3 | -3
   1 | 1 | 4 | one   |   9 |   |  0 |   4 | 2 |  4
   1 | 1 | 4 | one   |   9 |   |  0 |   5 | 5 | -5
   1 | 1 | 4 | one   |   9 |   |  0 |   6 | 5 | -5
   1 | 1 | 4 | one   |   9 |   |  0 |   7 | 0 |   
   1 | 1 | 4 | one   |   9 |   |  0 |   8 |   |   
   1 | 1 | 4 | one   |   9 |   |  0 |   9 |   |  0
   2 | 2 | 3 | two   |   1 | 1 | -1 |   1 | 1 | -1
   2 | 2 | 3 | two   |   1 | 1 | -1 |   2 | 2 |  2
   2 | 2 | 3 | two   |   1 | 1 | -1 |   3 | 3 | -3
   2 | 2 | 3 | two   |   1 | 1 | -1 |   4 | 2 |  4
   2 | 2 | 3 | two   |   1 | 1 | -1 |   5 | 5 | -5
   2 | 2 | 3 | two   |   1 | 1 | -1 |   6 | 5 | -5
   2 | 2 | 3 | two   |   1 | 1 | -1 |   7 | 0 |   
   2 | 2 | 3 | two   |   1 | 1 | -1 |   8 |   |   
   2 | 2 | 3 | two   |   1 | 1 | -1 |   9 |   |  0
   2 | 2 | 3 | two   |   2 | 2 |  2 |   1 | 1 | -1
   2 | 2 | 3 | two   |   2 | 2 |  2 |   2 | 2 |  2
   2 | 2 | 3 | two   |   2 | 2 |  2 |   3 | 3 | -3
   2 | 2 | 3 | two   |   2 | 2 |  2 |   4 | 2 |  4
   2 | 2 | 3 | two   |   2 | 2 |  2 |   5 | 5 | -5
   2 | 2 | 3 | two   |   2 | 2 |  2 |   6 | 5 | -5
   2 | 2 | 3 | two   |   2 | 2 |  2 |   7 | 0 |   
   2 | 2 | 3 | two   |   2 | 2 |  2 |   8 |   |   
   2 | 2 | 3 | two   |   2 | 2 |  2 |   9 |   |  0
   2 | 2 | 3 | two   |   3 | 3 | -3 |   1 | 1 | -1
   2 | 2 | 3 | two   |   3 | 3 | -3 |   2 | 2 |  2
   2 | 2 | 3 | two   |   3 | 3 | -3 |   3 | 3 | -3
   2 | 2 | 3 | two   |   3 | 3 | -3 |   4 | 2 |  4
   2 | 2 | 3 | two   |   3 | 3 | -3 |   5 | 5 | -5
   2 | 2 | 3 | two   |   3 | 3 | -3 |   6 | 5 | -5
   2 | 2 | 3 | two   |   3 | 3 | -3 |   7 | 0 |   
   2 | 2 | 3 | two   |   3 | 3 | -3 |   8 |   |   
   2 | 2 | 3 | two   |   3 | 3 | -3 |   9 |   |  0
   2 | 2 | 3 | two   |   4 | 2 |  4 |   1 | 1 | -1
   2 | 2 | 3 | two   |   4 | 2 |  4 |   2 | 2 |  2
   2 | 2 | 3 | two   |   4 | 2 |  4 |   3 | 3 | -3
   2 | 2 | 3 | two   |   4 | 2 |  4 |   4 | 2 |  4
   2 | 2 | 3 | two   |   4 | 2 |  4 |   5 | 5 | -5
   2 | 2 | 3 | two   |   4 | 2 |  4 |   6 | 5 | -5
   2 | 2 | 3 | two   |   4 | 2 |  4 |   7 | 0 |   
   2 | 2 | 3 | two   |   4 | 2 |  4 |   8 |   |   
   2 | 2 | 3 | two   |   4 | 2 |  4 |   9 |   |  0
   2 | 2 | 3 | two   |   5 | 5 | -5 |   1 | 1 | -1
   2 | 2 | 3 | two   |   5 | 5 | -5 |   2 | 2 |  2
   2 | 2 | 3 | two   |   5 | 5 | -5 |   3 | 3 | -3
   2 | 2 | 3 | two   |   5 | 5 | -5 |   4 | 2 |  4
   2 | 2 | 3 | two   |   5 | 5 | -5 |   5 | 5 | -5
   2 | 2 | 3 | two   |   5 | 5 | -5 |   6 | 5 | -5
   2 | 2 | 3 | two   |   5 | 5 | -5 |   7 | 0 |   
   2 | 2 | 3 | two   |   5 | 5 | -5 |   8 |   |   
   2 | 2 | 3 | two   |   5 | 5 | -5 |   9 |   |  0
   2 | 2 | 3 | two   |   6 | 5 | -5 |   1 | 1 | -1
   2 | 2 | 3 | two   |   6 | 5 | -5 |   2 | 2 |  2
   2 | 2 | 3 | two   |   6 | 5 | -5 |   3 | 3 | -3
   2 | 2 | 3 | two   |   6 | 5 | -5 |   4 | 2 |  4
   2 | 2 | 3 | two   |   6 | 5 | -5 |   5 | 5 | -5
   2 | 2 | 3 | two   |   6 | 5 | -5 |   6 | 5 | -5
   2 | 2 | 3 | two   |   6 | 5 | -5 |   7 | 0 |   
   2 | 2 | 3 | two   |   6 | 5 | -5 |   8 |   |   
   2 | 2 | 3 | two   |   6 | 5 | -5 |   9 |   |  0
   2 | 2 | 3 | two   |   7 | 0 |    |   1 | 1 | -1
   2 | 2 | 3 | two   |   7 | 0 |    |   2 | 2 |  2
   2 | 2 | 3 | two   |   7 | 0 |    |   3 | 3 | -3
   2 | 2 | 3 | two   |   7 | 0 |    |   4 | 2 |  4
   2 | 2 | 3 | two   |   7 | 0 |    |   5 | 5 | -5
   2 | 2 | 3 | two   |   7 | 0 |    |   6 | 5 | -5
   2 | 2 | 3 | two   |   7 | 0 |    |   7 | 0 |   
   2 | 2 | 3 | two   |   7 | 0 |    |   8 |   |   
   2 | 2 | 3 | two   |   7 | 0 |    |   9 |   |  0
   2 | 2 | 3 | two   |   8 |   |    |   1 | 1 | -1
   2 | 2 | 3 | two   |   8 |   |    |   2 | 2 |  2
   2 | 2 | 3 | two   |   8 |   |    |   3 | 3 | -3
   2 | 2 | 3 | two   |   8 |   |    |   4 | 2 |  4
   2 | 2 | 3 | two   |   8 |   |    |   5 | 5 | -5
   2 | 2 | 3 | two   |   8 |   |    |   6 | 5 | -5
   2 | 2 | 3 | two   |   8 |   |    |   7 | 0 |   
   2 | 2 | 3 | two   |   8 |   |    |   8 |   |   
   2 | 2 | 3 | two   |   8 |   |    |   9 |   |  0
   2 | 2 | 3 | two   |   9 |   |  0 |   1 | 1 | -1
   2 | 2 | 3 | two   |   9 |   |  0 |   2 | 2 |  2
   2 | 2 | 3 | two   |   9 |   |  0 |   3 | 3 | -3
   2 | 2 | 3 | two   |   9 |   |  0 |   4 | 2 |  4
   2 | 2 | 3 | two   |   9 |   |  0 |   5 | 5 | -5
   2 | 2 | 3 | two   |   9 |   |  0 |   6 | 5 | -5
   2 | 2 | 3 | two   |   9 |   |  0 |   7 | 0 |   
   2 | 2 | 3 | two   |   9 |   |  0 |   8 |   |   
   2 | 2 | 3 | two   |   9 |   |  0 |   9 |   |  0
   3 | 3 | 2 | three |   1 | 1 | -1 |   1 | 1 | -1
   3 | 3 | 2 | three |   1 | 1 | -1 |   2 | 2 |  2
   3 | 3 | 2 | three |   1 | 1 | -1 |   3 | 3 | -3
   3 | 3 | 2 | three |   1 | 1 | -1 |   4 | 2 |  4
   3 | 3 | 2 | three |   1 | 1 | -1 |   5 | 5 | -5
   3 | 3 | 2 | three |   1 | 1 | -1 |   6 | 5 | -5
   3 | 3 | 2 | three |   1 | 1 | -1 |   7 | 0 |   
   3 | 3 | 2 | three |   1 | 1 | -1 |   8 |   |   
   3 | 3 | 2 | three |   1 | 1 | -1 |   9 |   |  0
   3 | 3 | 2 | three |   2 | 2 |  2 |   1 | 1 | -1
   3 | 3 | 2 | three |   2 | 2 |  2 |   2 | 2 |  2
   3 | 3 | 2 | three |   2 | 2 |  2 |   3 | 3 | -3
   3 | 3 | 2 | three |   2 | 2 |  2 |   4 | 2 |  4
   3 | 3 | 2 | three |   2 | 2 |  2 |   5 | 5 | -5
   3 | 3 | 2 | three |   2 | 2 |  2 |   6 | 5 | -5
   3 | 3 | 2 | three |   2 | 2 |  2 |   7 | 0 |   
   3 | 3 | 2 | three |   2 | 2 |  2 |   8 |   |   
   3 | 3 | 2 | three |   2 | 2 |  2 |   9 |   |  0
   3 | 3 | 2 | three |   3 | 3 | -3 |   1 | 1 | -1
   3 | 3 | 2 | three |   3 | 3 | -3 |   2 | 2 |  2
   3 | 3 | 2 | three |   3 | 3 | -3 |   3 | 3 | -3
   3 | 3 | 2 | three |   3 | 3 | -3 |   4 | 2 |  4
   3 | 3 | 2 | three |   3 | 3 | -3 |   5 | 5 | -5
   3 | 3 | 2 | three |   3 | 3 | -3 |   6 | 5 | -5
   3 | 3 | 2 | three |   3 | 3 | -3 |   7 | 0 |   
   3 | 3 | 2 | three |   3 | 3 | -3 |   8 |   |   
   3 | 3 | 2 | three |   3 | 3 | -3 |   9 |   |  0
   3 | 3 | 2 | three |   4 | 2 |  4 |   1 | 1 | -1
   3 | 3 | 2 | three |   4 | 2 |  4 |   2 | 2 |  2
   3 | 3 | 2 | three |   4 | 2 |  4 |   3 | 3 | -3
   3 | 3 | 2 | three |   4 | 2 |  4 |   4 | 2 |  4
   3 | 3 | 2 | three |   4 | 2 |  4 |   5 | 5 | -5
   3 | 3 | 2 | three |   4 | 2 |  4 |   6 | 5 | -5
   3 | 3 | 2 | three |   4 | 2 |  4 |   7 | 0 |   
   3 | 3 | 2 | three |   4 | 2 |  4 |   8 |   |   
   3 | 3 | 2 | three |   4 | 2 |  4 |   9 |   |  0
   3 | 3 | 2 | three |   5 | 5 | -5 |   1 | 1 | -1
   3 | 3 | 2 | three |   5 | 5 | -5 |   2 | 2 |  2
   3 | 3 | 2 | three |   5 | 5 | -5 |   3 | 3 | -3
   3 | 3 | 2 | three |   5 | 5 | -5 |   4 | 2 |  4
   3 | 3 | 2 | three |   5 | 5 | -5 |   5 | 5 | -5
   3 | 3 | 2 | three |   5 | 5 | -5 |   6 | 5 | -5
   3 | 3 | 2 | three |   5 | 5 | -5 |   7 | 0 |   
   3 | 3 | 2 | three |   5 | 5 | -5 |   8 |   |   
   3 | 3 | 2 | three |   5 | 5 | -5 |   9 |   |  0
   3 | 3 | 2 | three |   6 | 5 | -5 |   1 | 1 | -1
   3 | 3 | 2 | three |   6 | 5 | -5 |   2 | 2 |  2
   3 | 3 | 2 | three |   6 | 5 | -5 |   3 | 3 | -3
   3 | 3 | 2 | three |   6 | 5 | -5 |   4 | 2 |  4
   3 | 3 | 2 | three |   6 | 5 | -5 |   5 | 5 | -5
   3 | 3 | 2 | three |   6 | 5 | -5 |   6 | 5 | -5
   3 | 3 | 2 | three |   6 | 5 | -5 |   7 | 0 |   
   3 | 3 | 2 | three |   6 | 5 | -5 |   8 |   |   
   3 | 3 | 2 | three |   6 | 5 | -5 |   9 |   |  0
   3 | 3 | 2 | three |   7 | 0 |    |   1 | 1 | -1
   3 | 3 | 2 | three |   7 | 0 |    |   2 | 2 |  2
   3 | 3 | 2 | three |   7 | 0 |    |   3 | 3 | -3
   3 | 3 | 2 | three |   7 | 0 |    |   4 | 2 |  4
   3 | 3 | 2 | three |   7 | 0 |    |   5 | 5 | -5
   3 | 3 | 2 | three |   7 | 0 |    |   6 | 5 | -5
   3 | 3 | 2 | three |   7 | 0 |    |   7 | 0 |   
   3 | 3 | 2 | three |   7 | 0 |    |   8 |   |   
   3 | 3 | 2 | three |   7 | 0 |    |   9 |   |  0
   3 | 3 | 2 | three |   8 |   |    |   1 | 1 | -1
   3 | 3 | 2 | three |   8 |   |    |   2 | 2 |  2
   3 | 3 | 2 | three |   8 |   |    |   3 | 3 | -3
   3 | 3 | 2 | three |   8 |   |    |   4 | 2 |  4
   3 | 3 | 2 | three |   8 |   |    |   5 | 5 | -5
   3 | 3 | 2 | three |   8 |   |    |   6 | 5 | -5
   3 | 3 | 2 | three |   8 |   |    |   7 | 0 |   
   3 | 3 | 2 | three |   8 |   |    |   8 |   |   
   3 | 3 | 2 | three |   8 |   |    |   9 |   |  0
   3 | 3 | 2 | three |   9 |   |  0 |   1 | 1 | -1
   3 | 3 | 2 | three |   9 |   |  0 |   2 | 2 |  2
   3 | 3 | 2 | three |   9 |   |  0 |   3 | 3 | -3
   3 | 3 | 2 | three |   9 |   |  0 |   4 | 2 |  4
   3 | 3 | 2 | three |   9 |   |  0 |   5 | 5 | -5
   3 | 3 | 2 | three |   9 |   |  0 |   6 | 5 | -5
   3 | 3 | 2 | three |   9 |   |  0 |   7 | 0 |   
   3 | 3 | 2 | three |   9 |   |  0 |   8 |   |   
   3 | 3 | 2 | three |   9 |   |  0 |   9 |   |  0
   4 | 4 | 1 | for   |   1 | 1 | -1 |   1 | 1 | -1
   4 | 4 | 1 | for   |   1 | 1 | -1 |   2 | 2 |  2
   4 | 4 | 1 | for   |   1 | 1 | -1 |   3 | 3 | -3
   4 | 4 | 1 | for   |   1 | 1 | -1 |   4 | 2 |  4
   4 | 4 | 1 | for   |   1 | 1 | -1 |   5 | 5 | -5
   4 | 4 | 1 | for   |   1 | 1 | -1 |   6 | 5 | -5
   4 | 4 | 1 | for   |   1 | 1 | -1 |   7 | 0 |   
   4 | 4 | 1 | for   |   1 | 1 | -1 |   8 |   |   
   4 | 4 | 1 | for   |   1 | 1 | -1 |   9 |   |  0
   4 | 4 | 1 | for   |   2 | 2 |  2 |   1 | 1 | -1
   4 | 4 | 1 | for   |   2 | 2 |  2 |   2 | 2 |  2
   4 | 4 | 1 | for   |   2 | 2 |  2 |   3 | 3 | -3
   4 | 4 | 1 | for   |   2 | 2 |  2 |   4 | 2 |  4
   4 | 4 | 1 | for   |   2 | 2 |  2 |   5 | 5 | -5
   4 | 4 | 1 | for   |   2 | 2 |  2 |   6 | 5 | -5
   4 | 4 | 1 | for   |   2 | 2 |  2 |   7 | 0 |   
   4 | 4 | 1 | for   |   2 | 2 |  2 |   8 |   |   
   4 | 4 | 1 | for   |   2 | 2 |  2 |   9 |   |  0
   4 | 4 | 1 | for   |   3 | 3 | -3 |   1 | 1 | -1
   4 | 4 | 1 | for   |   3 | 3 | -3 |   2 | 2 |  2
   4 | 4 | 1 | for   |   3 | 3 | -3 |   3 | 3 | -3
   4 | 4 | 1 | for   |   3 | 3 | -3 |   4 | 2 |  4
   4 | 4 | 1 | for   |   3 | 3 | -3 |   5 | 5 | -5
   4 | 4 | 1 | for   |   3 | 3 | -3 |   6 | 5 | -5
   4 | 4 | 1 | for   |   3 | 3 | -3 |   7 | 0 |   
   4 | 4 | 1 | for   |   3 | 3 | -3 |   8 |   |   
   4 | 4 | 1 | for   |   3 | 3 | -3 |   9 |   |  0
   4 | 4 | 1 | for   |   4 | 2 |  4 |   1 | 1 | -1
   4 | 4 | 1 | for   |   4 | 2 |  4 |   2 | 2 |  2
   4 | 4 | 1 | for   |   4 | 2 |  4 |   3 | 3 | -3
   4 | 4 | 1 | for   |   4 | 2 |  4 |   4 | 2 |  4
   4 | 4 | 1 | for   |   4 | 2 |  4 |   5 | 5 | -5
   4 | 4 | 1 | for   |   4 | 2 |  4 |   6 | 5 | -5
   4 | 4 | 1 | for   |   4 | 2 |  4 |   7 | 0 |   
   4 | 4 | 1 | for   |   4 | 2 |  4 |   8 |   |   
   4 | 4 | 1 | for   |   4 | 2 |  4 |   9 |   |  0
   4 | 4 | 1 | for   |   5 | 5 | -5 |   1 | 1 | -1
   4 | 4 | 1 | for   |   5 | 5 | -5 |   2 | 2 |  2
   4 | 4 | 1 | for   |   5 | 5 | -5 |   3 | 3 | -3
   4 | 4 | 1 | for   |   5 | 5 | -5 |   4 | 2 |  4
   4 | 4 | 1 | for   |   5 | 5 | -5 |   5 | 5 | -5
   4 | 4 | 1 | for   |   5 | 5 | -5 |   6 | 5 | -5
   4 | 4 | 1 | for   |   5 | 5 | -5 |   7 | 0 |   
   4 | 4 | 1 | for   |   5 | 5 | -5 |   8 |   |   
   4 | 4 | 1 | for   |   5 | 5 | -5 |   9 |   |  0
   4 | 4 | 1 | for   |   6 | 5 | -5 |   1 | 1 | -1
   4 | 4 | 1 | for   |   6 | 5 | -5 |   2 | 2 |  2
   4 | 4 | 1 | for   |   6 | 5 | -5 |   3 | 3 | -3
   4 | 4 | 1 | for   |   6 | 5 | -5 |   4 | 2 |  4
   4 | 4 | 1 | for   |   6 | 5 | -5 |   5 | 5 | -5
   4 | 4 | 1 | for   |   6 | 5 | -5 |   6 | 5 | -5
   4 | 4 | 1 | for   |   6 | 5 | -5 |   7 | 0 |   
   4 | 4 | 1 | for   |   6 | 5 | -5 |   8 |   |   
   4 | 4 | 1 | for   |   6 | 5 | -5 |   9 |   |  0
   4 | 4 | 1 | for   |   7 | 0 |    |   1 | 1 | -1
   4 | 4 | 1 | for   |   7 | 0 |    |   2 | 2 |  2
   4 | 4 | 1 | for   |   7 | 0 |    |   3 | 3 | -3
   4 | 4 | 1 | for   |   7 | 0 |    |   4 | 2 |  4
   4 | 4 | 1 | for   |   7 | 0 |    |   5 | 5 | -5
   4 | 4 | 1 | for   |   7 | 0 |    |   6 | 5 | -5
   4 | 4 | 1 | for   |   7 | 0 |    |   7 | 0 |   
   4 | 4 | 1 | for   |   7 | 0 |    |   8 |   |   
   4 | 4 | 1 | for   |   7 | 0 |    |   9 |   |  0
   4 | 4 | 1 | for   |   8 |   |    |   1 | 1 | -1
   4 | 4 | 1 | for   |   8 |   |    |   2 | 2 |  2
   4 | 4 | 1 | for   |   8 |   |    |   3 | 3 | -3
   4 | 4 | 1 | for   |   8 |   |    |   4 | 2 |  4
   4 | 4 | 1 | for   |   8 |   |    |   5 | 5 | -5
   4 | 4 | 1 | for   |   8 |   |    |   6 | 5 | -5
   4 | 4 | 1 | for   |   8 |   |    |   7 | 0 |   
   4 | 4 | 1 | for   |   8 |   |    |   8 |   |   
   4 | 4 | 1 | for   |   8 |   |    |   9 |   |  0
   4 | 4 | 1 | for   |   9 |   |  0 |   1 | 1 | -1
   4 | 4 | 1 | for   |   9 |   |  0 |   2 | 2 |  2
   4 | 4 | 1 | for   |   9 |   |  0 |   3 | 3 | -3
   4 | 4 | 1 | for   |   9 |   |  0 |   4 | 2 |  4
   4 | 4 | 1 | for   |   9 |   |  0 |   5 | 5 | -5
   4 | 4 | 1 | for   |   9 |   |  0 |   6 | 5 | -5
   4 | 4 | 1 | for   |   9 |   |  0 |   7 | 0 |   
   4 | 4 | 1 | for   |   9 |   |  0 |   8 |   |   
   4 | 4 | 1 | for   |   9 |   |  0 |   9 |   |  0
   5 | 5 | 0 | five  |   1 | 1 | -1 |   1 | 1 | -1
   5 | 5 | 0 | five  |   1 | 1 | -1 |   2 | 2 |  2
   5 | 5 | 0 | five  |   1 | 1 | -1 |   3 | 3 | -3
   5 | 5 | 0 | five  |   1 | 1 | -1 |   4 | 2 |  4
   5 | 5 | 0 | five  |   1 | 1 | -1 |   5 | 5 | -5
   5 | 5 | 0 | five  |   1 | 1 | -1 |   6 | 5 | -5
   5 | 5 | 0 | five  |   1 | 1 | -1 |   7 | 0 |   
   5 | 5 | 0 | five  |   1 | 1 | -1 |   8 |   |   
   5 | 5 | 0 | five  |   1 | 1 | -1 |   9 |   |  0
   5 | 5 | 0 | five  |   2 | 2 |  2 |   1 | 1 | -1
   5 | 5 | 0 | five  |   2 | 2 |  2 |   2 | 2 |  2
   5 | 5 | 0 | five  |   2 | 2 |  2 |   3 | 3 | -3
   5 | 5 | 0 | five  |   2 | 2 |  2 |   4 | 2 |  4
   5 | 5 | 0 | five  |   2 | 2 |  2 |   5 | 5 | -5
   5 | 5 | 0 | five  |   2 | 2 |  2 |   6 | 5 | -5
   5 | 5 | 0 | five  |   2 | 2 |  2 |   7 | 0 |   
   5 | 5 | 0 | five  |   2 | 2 |  2 |   8 |   |   
   5 | 5 | 0 | five  |   2 | 2 |  2 |   9 |   |  0
   5 | 5 | 0 | five  |   3 | 3 | -3 |   1 | 1 | -1
   5 | 5 | 0 | five  |   3 | 3 | -3 |   2 | 2 |  2
   5 | 5 | 0 | five  |   3 | 3 | -3 |   3 | 3 | -3
   5 | 5 | 0 | five  |   3 | 3 | -3 |   4 | 2 |  4
   5 | 5 | 0 | five  |   3 | 3 | -3 |   5 | 5 | -5
   5 | 5 | 0 | five  |   3 | 3 | -3 |   6 | 5 | -5
   5 | 5 | 0 | five  |   3 | 3 | -3 |   7 | 0 |   
   5 | 5 | 0 | five  |   3 | 3 | -3 |   8 |   |   
   5 | 5 | 0 | five  |   3 | 3 | -3 |   9 |   |  0
   5 | 5 | 0 | five  |   4 | 2 |  4 |   1 | 1 | -1
   5 | 5 | 0 | five  |   4 | 2 |  4 |   2 | 2 |  2
   5 | 5 | 0 | five  |   4 | 2 |  4 |   3 | 3 | -3
   5 | 5 | 0 | five  |   4 | 2 |  4 |   4 | 2 |  4
   5 | 5 | 0 | five  |   4 | 2 |  4 |   5 | 5 | -5
   5 | 5 | 0 | five  |   4 | 2 |  4 |   6 | 5 | -5
   5 | 5 | 0 | five  |   4 | 2 |  4 |   7 | 0 |   
   5 | 5 | 0 | five  |   4 | 2 |  4 |   8 |   |   
   5 | 5 | 0 | five  |   4 | 2 |  4 |   9 |   |  0
   5 | 5 | 0 | five  |   5 | 5 | -5 |   1 | 1 | -1
   5 | 5 | 0 | five  |   5 | 5 | -5 |   2 | 2 |  2
   5 | 5 | 0 | five  |   5 | 5 | -5 |   3 | 3 | -3
   5 | 5 | 0 | five  |   5 | 5 | -5 |   4 | 2 |  4
   5 | 5 | 0 | five  |   5 | 5 | -5 |   5 | 5 | -5
   5 | 5 | 0 | five  |   5 | 5 | -5 |   6 | 5 | -5
   5 | 5 | 0 | five  |   5 | 5 | -5 |   7 | 0 |   
   5 | 5 | 0 | five  |   5 | 5 | -5 |   8 |   |   
   5 | 5 | 0 | five  |   5 | 5 | -5 |   9 |   |  0
   5 | 5 | 0 | five  |   6 | 5 | -5 |   1 | 1 | -1
   5 | 5 | 0 | five  |   6 | 5 | -5 |   2 | 2 |  2
   5 | 5 | 0 | five  |   6 | 5 | -5 |   3 | 3 | -3
   5 | 5 | 0 | five  |   6 | 5 | -5 |   4 | 2 |  4
   5 | 5 | 0 | five  |   6 | 5 | -5 |   5 | 5 | -5
   5 | 5 | 0 | five  |   6 | 5 | -5 |   6 | 5 | -5
   5 | 5 | 0 | five  |   6 | 5 | -5 |   7 | 0 |   
   5 | 5 | 0 | five  |   6 | 5 | -5 |   8 |   |   
   5 | 5 | 0 | five  |   6 | 5 | -5 |   9 |   |  0
   5 | 5 | 0 | five  |   7 | 0 |    |   1 | 1 | -1
   5 | 5 | 0 | five  |   7 | 0 |    |   2 | 2 |  2
   5 | 5 | 0 | five  |   7 | 0 |    |   3 | 3 | -3
   5 | 5 | 0 | five  |   7 | 0 |    |   4 | 2 |  4
   5 | 5 | 0 | five  |   7 | 0 |    |   5 | 5 | -5
   5 | 5 | 0 | five  |   7 | 0 |    |   6 | 5 | -5
   5 | 5 | 0 | five  |   7 | 0 |    |   7 | 0 |   
   5 | 5 | 0 | five  |   7 | 0 |    |   8 |   |   
   5 | 5 | 0 | five  |   7 | 0 |    |   9 |   |  0
   5 | 5 | 0 | five  |   8 |   |    |   1 | 1 | -1
   5 | 5 | 0 | five  |   8 |   |    |   2 | 2 |  2
   5 | 5 | 0 | five  |   8 |   |    |   3 | 3 | -3
   5 | 5 | 0 | five  |   8 |   |    |   4 | 2 |  4
   5 | 5 | 0 | five  |   8 |   |    |   5 | 5 | -5
   5 | 5 | 0 | five  |   8 |   |    |   6 | 5 | -5
   5 | 5 | 0 | five  |   8 |   |    |   7 | 0 |   
   5 | 5 | 0 | five  |   8 |   |    |   8 |   |   
   5 | 5 | 0 | five  |   8 |   |    |   9 |   |  0
   5 | 5 | 0 | five  |   9 |   |  0 |   1 | 1 | -1
   5 | 5 | 0 | five  |   9 |   |  0 |   2 | 2 |  2
   5 | 5 | 0 | five  |   9 |   |  0 |   3 | 3 | -3
   5 | 5 | 0 | five  |   9 |   |  0 |   4 | 2 |  4
   5 | 5 | 0 | five  |   9 |   |  0 |   5 | 5 | -5
   5 | 5 | 0 | five  |   9 |   |  0 |   6 | 5 | -5
   5 | 5 | 0 | five  |   9 |   |  0 |   7 | 0 |   
   5 | 5 | 0 | five  |   9 |   |  0 |   8 |   |   
   5 | 5 | 0 | five  |   9 |   |  0 |   9 |   |  0
   6 | 6 | 6 | six   |   1 | 1 | -1 |   1 | 1 | -1
   6 | 6 | 6 | six   |   1 | 1 | -1 |   2 | 2 |  2
   6 | 6 | 6 | six   |   1 | 1 | -1 |   3 | 3 | -3
   6 | 6 | 6 | six   |   1 | 1 | -1 |   4 | 2 |  4
   6 | 6 | 6 | six   |   1 | 1 | -1 |   5 | 5 | -5
   6 | 6 | 6 | six   |   1 | 1 | -1 |   6 | 5 | -5
   6 | 6 | 6 | six   |   1 | 1 | -1 |   7 | 0 |   
   6 | 6 | 6 | six   |   1 | 1 | -1 |   8 |   |   
   6 | 6 | 6 | six   |   1 | 1 | -1 |   9 |   |  0
   6 | 6 | 6 | six   |   2 | 2 |  2 |   1 | 1 | -1
   6 | 6 | 6 | six   |   2 | 2 |  2 |   2 | 2 |  2
   6 | 6 | 6 | six   |   2 | 2 |  2 |   3 | 3 | -3
   6 | 6 | 6 | six   |   2 | 2 |  2 |   4 | 2 |  4
   6 | 6 | 6 | six   |   2 | 2 |  2 |   5 | 5 | -5
   6 | 6 | 6 | six   |   2 | 2 |  2 |   6 | 5 | -5
   6 | 6 | 6 | six   |   2 | 2 |  2 |   7 | 0 |   
   6 | 6 | 6 | six   |   2 | 2 |  2 |   8 |   |   
   6 | 6 | 6 | six   |   2 | 2 |  2 |   9 |   |  0
   6 | 6 | 6 | six   |   3 | 3 | -3 |   1 | 1 | -1
   6 | 6 | 6 | six   |   3 | 3 | -3 |   2 | 2 |  2
   6 | 6 | 6 | six   |   3 | 3 | -3 |   3 | 3 | -3
   6 | 6 | 6 | six   |   3 | 3 | -3 |   4 | 2 |  4
   6 | 6 | 6 | six   |   3 | 3 | -3 |   5 | 5 | -5
   6 | 6 | 6 | six   |   3 | 3 | -3 |   6 | 5 | -5
   6 | 6 | 6 | six   |   3 | 3 | -3 |   7 | 0 |   
   6 | 6 | 6 | six   |   3 | 3 | -3 |   8 |   |   
   6 | 6 | 6 | six   |   3 | 3 | -3 |   9 |   |  0
   6 | 6 | 6 | six   |   4 | 2 |  4 |   1 | 1 | -1
   6 | 6 | 6 | six   |   4 | 2 |  4 |   2 | 2 |  2
   6 | 6 | 6 | six   |   4 | 2 |  4 |   3 | 3 | -3
   6 | 6 | 6 | six   |   4 | 2 |  4 |   4 | 2 |  4
   6 | 6 | 6 | six   |   4 | 2 |  4 |   5 | 5 | -5
   6 | 6 | 6 | six   |   4 | 2 |  4 |   6 | 5 | -5
   6 | 6 | 6 | six   |   4 | 2 |  4 |   7 | 0 |   
   6 | 6 | 6 | six   |   4 | 2 |  4 |   8 |   |   
   6 | 6 | 6 | six   |   4 | 2 |  4 |   9 |   |  0
   6 | 6 | 6 | six   |   5 | 5 | -5 |   1 | 1 | -1
   6 | 6 | 6 | six   |   5 | 5 | -5 |   2 | 2 |  2
   6 | 6 | 6 | six   |   5 | 5 | -5 |   3 | 3 | -3
   6 | 6 | 6 | six   |   5 | 5 | -5 |   4 | 2 |  4
   6 | 6 | 6 | six   |   5 | 5 | -5 |   5 | 5 | -5
   6 | 6 | 6 | six   |   5 | 5 | -5 |   6 | 5 | -5
   6 | 6 | 6 | six   |   5 | 5 | -5 |   7 | 0 |   
   6 | 6 | 6 | six   |   5 | 5 | -5 |   8 |   |   
   6 | 6 | 6 | six   |   5 | 5 | -5 |   9 |   |  0
   6 | 6 | 6 | six   |   6 | 5 | -5 |   1 | 1 | -1
   6 | 6 | 6 | six   |   6 | 5 | -5 |   2 | 2 |  2
   6 | 6 | 6 | six   |   6 | 5 | -5 |   3 | 3 | -3
   6 | 6 | 6 | six   |   6 | 5 | -5 |   4 | 2 |  4
   6 | 6 | 6 | six   |   6 | 5 | -5 |   5 | 5 | -5
   6 | 6 | 6 | six   |   6 | 5 | -5 |   6 | 5 | -5
   6 | 6 | 6 | six   |   6 | 5 | -5 |   7 | 0 |   
   6 | 6 | 6 | six   |   6 | 5 | -5 |   8 |   |   
   6 | 6 | 6 | six   |   6 | 5 | -5 |   9 |   |  0
   6 | 6 | 6 | six   |   7 | 0 |    |   1 | 1 | -1
   6 | 6 | 6 | six   |   7 | 0 |    |   2 | 2 |  2
   6 | 6 | 6 | six   |   7 | 0 |    |   3 | 3 | -3
   6 | 6 | 6 | six   |   7 | 0 |    |   4 | 2 |  4
   6 | 6 | 6 | six   |   7 | 0 |    |   5 | 5 | -5
   6 | 6 | 6 | six   |   7 | 0 |    |   6 | 5 | -5
   6 | 6 | 6 | six   |   7 | 0 |    |   7 | 0 |   
   6 | 6 | 6 | six   |   7 | 0 |    |   8 |   |   
   6 | 6 | 6 | six   |   7 | 0 |    |   9 |   |  0
   6 | 6 | 6 | six   |   8 |   |    |   1 | 1 | -1
   6 | 6 | 6 | six   |   8 |   |    |   2 | 2 |  2
   6 | 6 | 6 | six   |   8 |   |    |   3 | 3 | -3
   6 | 6 | 6 | six   |   8 |   |    |   4 | 2 |  4
   6 | 6 | 6 | six   |   8 |   |    |   5 | 5 | -5
   6 | 6 | 6 | six   |   8 |   |    |   6 | 5 | -5
   6 | 6 | 6 | six   |   8 |   |    |   7 | 0 |   
   6 | 6 | 6 | six   |   8 |   |    |   8 |   |   
   6 | 6 | 6 | six   |   8 |   |    |   9 |   |  0
   6 | 6 | 6 | six   |   9 |   |  0 |   1 | 1 | -1
   6 | 6 | 6 | six   |   9 |   |  0 |   2 | 2 |  2
   6 | 6 | 6 | six   |   9 |   |  0 |   3 | 3 | -3
   6 | 6 | 6 | six   |   9 |   |  0 |   4 | 2 |  4
   6 | 6 | 6 | six   |   9 |   |  0 |   5 | 5 | -5
   6 | 6 | 6 | six   |   9 |   |  0 |   6 | 5 | -5
   6 | 6 | 6 | six   |   9 |   |  0 |   7 | 0 |   
   6 | 6 | 6 | six   |   9 |   |  0 |   8 |   |   
   6 | 6 | 6 | six   |   9 |   |  0 |   9 |   |  0
   7 | 7 | 7 | seven |   1 | 1 | -1 |   1 | 1 | -1
   7 | 7 | 7 | seven |   1 | 1 | -1 |   2 | 2 |  2
   7 | 7 | 7 | seven |   1 | 1 | -1 |   3 | 3 | -3
   7 | 7 | 7 | seven |   1 | 1 | -1 |   4 | 2 |  4
   7 | 7 | 7 | seven |   1 | 1 | -1 |   5 | 5 | -5
   7 | 7 | 7 | seven |   1 | 1 | -1 |   6 | 5 | -5
   7 | 7 | 7 | seven |   1 | 1 | -1 |   7 | 0 |   
   7 | 7 | 7 | seven |   1 | 1 | -1 |   8 |   |   
   7 | 7 | 7 | seven |   1 | 1 | -1 |   9 |   |  0
   7 | 7 | 7 | seven |   2 | 2 |  2 |   1 | 1 | -1
   7 | 7 | 7 | seven |   2 | 2 |  2 |   2 | 2 |  2
   7 | 7 | 7 | seven |   2 | 2 |  2 |   3 | 3 | -3
   7 | 7 | 7 | seven |   2 | 2 |  2 |   4 | 2 |  4
   7 | 7 | 7 | seven |   2 | 2 |  2 |   5 | 5 | -5
   7 | 7 | 7 | seven |   2 | 2 |  2 |   6 | 5 | -5
   7 | 7 | 7 | seven |   2 | 2 |  2 |   7 | 0 |   
   7 | 7 | 7 | seven |   2 | 2 |  2 |   8 |   |   
   7 | 7 | 7 | seven |   2 | 2 |  2 |   9 |   |  0
   7 | 7 | 7 | seven |   3 | 3 | -3 |   1 | 1 | -1
   7 | 7 | 7 | seven |   3 | 3 | -3 |   2 | 2 |  2
   7 | 7 | 7 | seven |   3 | 3 | -3 |   3 | 3 | -3
   7 | 7 | 7 | seven |   3 | 3 | -3 |   4 | 2 |  4
   7 | 7 | 7 | seven |   3 | 3 | -3 |   5 | 5 | -5
   7 | 7 | 7 | seven |   3 | 3 | -3 |   6 | 5 | -5
   7 | 7 | 7 | seven |   3 | 3 | -3 |   7 | 0 |   
   7 | 7 | 7 | seven |   3 | 3 | -3 |   8 |   |   
   7 | 7 | 7 | seven |   3 | 3 | -3 |   9 |   |  0
   7 | 7 | 7 | seven |   4 | 2 |  4 |   1 | 1 | -1
   7 | 7 | 7 | seven |   4 | 2 |  4 |   2 | 2 |  2
   7 | 7 | 7 | seven |   4 | 2 |  4 |   3 | 3 | -3
   7 | 7 | 7 | seven |   4 | 2 |  4 |   4 | 2 |  4
   7 | 7 | 7 | seven |   4 | 2 |  4 |   5 | 5 | -5
   7 | 7 | 7 | seven |   4 | 2 |  4 |   6 | 5 | -5
   7 | 7 | 7 | seven |   4 | 2 |  4 |   7 | 0 |   
   7 | 7 | 7 | seven |   4 | 2 |  4 |   8 |   |   
   7 | 7 | 7 | seven |   4 | 2 |  4 |   9 |   |  0
   7 | 7 | 7 | seven |   5 | 5 | -5 |   1 | 1 | -1
   7 | 7 | 7 | seven |   5 | 5 | -5 |   2 | 2 |  2
   7 | 7 | 7 | seven |   5 | 5 | -5 |   3 | 3 | -3
   7 | 7 | 7 | seven |   5 | 5 | -5 |   4 | 2 |  4
   7 | 7 | 7 | seven |   5 | 5 | -5 |   5 | 5 | -5
   7 | 7 | 7 | seven |   5 | 5 | -5 |   6 | 5 | -5
   7 | 7 | 7 | seven |   5 | 5 | -5 |   7 | 0 |   
   7 | 7 | 7 | seven |   5 | 5 | -5 |   8 |   |   
   7 | 7 | 7 | seven |   5 | 5 | -5 |   9 |   |  0
   7 | 7 | 7 | seven |   6 | 5 | -5 |   1 | 1 | -1
   7 | 7 | 7 | seven |   6 | 5 | -5 |   2 | 2 |  2
   7 | 7 | 7 | seven |   6 | 5 | -5 |   3 | 3 | -3
   7 | 7 | 7 | seven |   6 | 5 | -5 |   4 | 2 |  4
   7 | 7 | 7 | seven |   6 | 5 | -5 |   5 | 5 | -5
   7 | 7 | 7 | seven |   6 | 5 | -5 |   6 | 5 | -5
   7 | 7 | 7 | seven |   6 | 5 | -5 |   7 | 0 |   
   7 | 7 | 7 | seven |   6 | 5 | -5 |   8 |   |   
   7 | 7 | 7 | seven |   6 | 5 | -5 |   9 |   |  0
   7 | 7 | 7 | seven |   7 | 0 |    |   1 | 1 | -1
   7 | 7 | 7 | seven |   7 | 0 |    |   2 | 2 |  2
   7 | 7 | 7 | seven |   7 | 0 |    |   3 | 3 | -3
   7 | 7 | 7 | seven |   7 | 0 |    |   4 | 2 |  4
   7 | 7 | 7 | seven |   7 | 0 |    |   5 | 5 | -5
   7 | 7 | 7 | seven |   7 | 0 |    |   6 | 5 | -5
   7 | 7 | 7 | seven |   7 | 0 |    |   7 | 0 |   
   7 | 7 | 7 | seven |   7 | 0 |    |   8 |   |   
   7 | 7 | 7 | seven |   7 | 0 |    |   9 |   |  0
   7 | 7 | 7 | seven |   8 |   |    |   1 | 1 | -1
   7 | 7 | 7 | seven |   8 |   |    |   2 | 2 |  2
   7 | 7 | 7 | seven |   8 |   |    |   3 | 3 | -3
   7 | 7 | 7 | seven |   8 |   |    |   4 | 2 |  4
   7 | 7 | 7 | seven |   8 |   |    |   5 | 5 | -5
   7 | 7 | 7 | seven |   8 |   |    |   6 | 5 | -5
   7 | 7 | 7 | seven |   8 |   |    |   7 | 0 |   
   7 | 7 | 7 | seven |   8 |   |    |   8 |   |   
   7 | 7 | 7 | seven |   8 |   |    |   9 |   |  0
   7 | 7 | 7 | seven |   9 |   |  0 |   1 | 1 | -1
   7 | 7 | 7 | seven |   9 |   |  0 |   2 | 2 |  2
   7 | 7 | 7 | seven |   9 |   |  0 |   3 | 3 | -3
   7 | 7 | 7 | seven |   9 |   |  0 |   4 | 2 |  4
   7 | 7 | 7 | seven |   9 |   |  0 |   5 | 5 | -5
   7 | 7 | 7 | seven |   9 |   |  0 |   6 | 5 | -5
   7 | 7 | 7 | seven |   9 |   |  0 |   7 | 0 |   
   7 | 7 | 7 | seven |   9 |   |  0 |   8 |   |   
   7 | 7 | 7 | seven |   9 |   |  0 |   9 |   |  0
   8 | 8 | 8 | eight |   1 | 1 | -1 |   1 | 1 | -1
   8 | 8 | 8 | eight |   1 | 1 | -1 |   2 | 2 |  2
   8 | 8 | 8 | eight |   1 | 1 | -1 |   3 | 3 | -3
   8 | 8 | 8 | eight |   1 | 1 | -1 |   4 | 2 |  4
   8 | 8 | 8 | eight |   1 | 1 | -1 |   5 | 5 | -5
   8 | 8 | 8 | eight |   1 | 1 | -1 |   6 | 5 | -5
   8 | 8 | 8 | eight |   1 | 1 | -1 |   7 | 0 |   
   8 | 8 | 8 | eight |   1 | 1 | -1 |   8 |   |   
   8 | 8 | 8 | eight |   1 | 1 | -1 |   9 |   |  0
   8 | 8 | 8 | eight |   2 | 2 |  2 |   1 | 1 | -1
   8 | 8 | 8 | eight |   2 | 2 |  2 |   2 | 2 |  2
   8 | 8 | 8 | eight |   2 | 2 |  2 |   3 | 3 | -3
   8 | 8 | 8 | eight |   2 | 2 |  2 |   4 | 2 |  4
   8 | 8 | 8 | eight |   2 | 2 |  2 |   5 | 5 | -5
   8 | 8 | 8 | eight |   2 | 2 |  2 |   6 | 5 | -5
   8 | 8 | 8 | eight |   2 | 2 |  2 |   7 | 0 |   
   8 | 8 | 8 | eight |   2 | 2 |  2 |   8 |   |   
   8 | 8 | 8 | eight |   2 | 2 |  2 |   9 |   |  0
   8 | 8 | 8 | eight |   3 | 3 | -3 |   1 | 1 | -1
   8 | 8 | 8 | eight |   3 | 3 | -3 |   2 | 2 |  2
   8 | 8 | 8 | eight |   3 | 3 | -3 |   3 | 3 | -3
   8 | 8 | 8 | eight |   3 | 3 | -3 |   4 | 2 |  4
   8 | 8 | 8 | eight |   3 | 3 | -3 |   5 | 5 | -5
   8 | 8 | 8 | eight |   3 | 3 | -3 |   6 | 5 | -5
   8 | 8 | 8 | eight |   3 | 3 | -3 |   7 | 0 |   
   8 | 8 | 8 | eight |   3 | 3 | -3 |   8 |   |   
   8 | 8 | 8 | eight |   3 | 3 | -3 |   9 |   |  0
   8 | 8 | 8 | eight |   4 | 2 |  4 |   1 | 1 | -1
   8 | 8 | 8 | eight |   4 | 2 |  4 |   2 | 2 |  2
   8 | 8 | 8 | eight |   4 | 2 |  4 |   3 | 3 | -3
   8 | 8 | 8 | eight |   4 | 2 |  4 |   4 | 2 |  4
   8 | 8 | 8 | eight |   4 | 2 |  4 |   5 | 5 | -5
   8 | 8 | 8 | eight |   4 | 2 |  4 |   6 | 5 | -5
   8 | 8 | 8 | eight |   4 | 2 |  4 |   7 | 0 |   
   8 | 8 | 8 | eight |   4 | 2 |  4 |   8 |   |   
   8 | 8 | 8 | eight |   4 | 2 |  4 |   9 |   |  0
   8 | 8 | 8 | eight |   5 | 5 | -5 |   1 | 1 | -1
   8 | 8 | 8 | eight |   5 | 5 | -5 |   2 | 2 |  2
   8 | 8 | 8 | eight |   5 | 5 | -5 |   3 | 3 | -3
   8 | 8 | 8 | eight |   5 | 5 | -5 |   4 | 2 |  4
   8 | 8 | 8 | eight |   5 | 5 | -5 |   5 | 5 | -5
   8 | 8 | 8 | eight |   5 | 5 | -5 |   6 | 5 | -5
   8 | 8 | 8 | eight |   5 | 5 | -5 |   7 | 0 |   
   8 | 8 | 8 | eight |   5 | 5 | -5 |   8 |   |   
   8 | 8 | 8 | eight |   5 | 5 | -5 |   9 |   |  0
   8 | 8 | 8 | eight |   6 | 5 | -5 |   1 | 1 | -1
   8 | 8 | 8 | eight |   6 | 5 | -5 |   2 | 2 |  2
   8 | 8 | 8 | eight |   6 | 5 | -5 |   3 | 3 | -3
   8 | 8 | 8 | eight |   6 | 5 | -5 |   4 | 2 |  4
   8 | 8 | 8 | eight |   6 | 5 | -5 |   5 | 5 | -5
   8 | 8 | 8 | eight |   6 | 5 | -5 |   6 | 5 | -5
   8 | 8 | 8 | eight |   6 | 5 | -5 |   7 | 0 |   
   8 | 8 | 8 | eight |   6 | 5 | -5 |   8 |   |   
   8 | 8 | 8 | eight |   6 | 5 | -5 |   9 |   |  0
   8 | 8 | 8 | eight |   7 | 0 |    |   1 | 1 | -1
   8 | 8 | 8 | eight |   7 | 0 |    |   2 | 2 |  2
   8 | 8 | 8 | eight |   7 | 0 |    |   3 | 3 | -3
   8 | 8 | 8 | eight |   7 | 0 |    |   4 | 2 |  4
   8 | 8 | 8 | eight |   7 | 0 |    |   5 | 5 | -5
   8 | 8 | 8 | eight |   7 | 0 |    |   6 | 5 | -5
   8 | 8 | 8 | eight |   7 | 0 |    |   7 | 0 |   
   8 | 8 | 8 | eight |   7 | 0 |    |   8 |   |   
   8 | 8 | 8 | eight |   7 | 0 |    |   9 |   |  0
   8 | 8 | 8 | eight |   8 |   |    |   1 | 1 | -1
   8 | 8 | 8 | eight |   8 |   |    |   2 | 2 |  2
   8 | 8 | 8 | eight |   8 |   |    |   3 | 3 | -3
   8 | 8 | 8 | eight |   8 |   |    |   4 | 2 |  4
   8 | 8 | 8 | eight |   8 |   |    |   5 | 5 | -5
   8 | 8 | 8 | eight |   8 |   |    |   6 | 5 | -5
   8 | 8 | 8 | eight |   8 |   |    |   7 | 0 |   
   8 | 8 | 8 | eight |   8 |   |    |   8 |   |   
   8 | 8 | 8 | eight |   8 |   |    |   9 |   |  0
   8 | 8 | 8 | eight |   9 |   |  0 |   1 | 1 | -1
   8 | 8 | 8 | eight |   9 |   |  0 |   2 | 2 |  2
   8 | 8 | 8 | eight |   9 |   |  0 |   3 | 3 | -3
   8 | 8 | 8 | eight |   9 |   |  0 |   4 | 2 |  4
   8 | 8 | 8 | eight |   9 |   |  0 |   5 | 5 | -5
   8 | 8 | 8 | eight |   9 |   |  0 |   6 | 5 | -5
   8 | 8 | 8 | eight |   9 |   |  0 |   7 | 0 |   
   8 | 8 | 8 | eight |   9 |   |  0 |   8 |   |   
   8 | 8 | 8 | eight |   9 |   |  0 |   9 |   |  0
   9 | 0 |   | zero  |   1 | 1 | -1 |   1 | 1 | -1
   9 | 0 |   | zero  |   1 | 1 | -1 |   2 | 2 |  2
   9 | 0 |   | zero  |   1 | 1 | -1 |   3 | 3 | -3
   9 | 0 |   | zero  |   1 | 1 | -1 |   4 | 2 |  4
   9 | 0 |   | zero  |   1 | 1 | -1 |   5 | 5 | -5
   9 | 0 |   | zero  |   1 | 1 | -1 |   6 | 5 | -5
   9 | 0 |   | zero  |   1 | 1 | -1 |   7 | 0 |   
   9 | 0 |   | zero  |   1 | 1 | -1 |   8 |   |   
   9 | 0 |   | zero  |   1 | 1 | -1 |   9 |   |  0
   9 | 0 |   | zero  |   2 | 2 |  2 |   1 | 1 | -1
   9 | 0 |   | zero  |   2 | 2 |  2 |   2 | 2 |  2
   9 | 0 |   | zero  |   2 | 2 |  2 |   3 | 3 | -3
   9 | 0 |   | zero  |   2 | 2 |  2 |   4 | 2 |  4
   9 | 0 |   | zero  |   2 | 2 |  2 |   5 | 5 | -5
   9 | 0 |   | zero  |   2 | 2 |  2 |   6 | 5 | -5
   9 | 0 |   | zero  |   2 | 2 |  2 |   7 | 0 |   
   9 | 0 |   | zero  |   2 | 2 |  2 |   8 |   |   
   9 | 0 |   | zero  |   2 | 2 |  2 |   9 |   |  0
   9 | 0 |   | zero  |   3 | 3 | -3 |   1 | 1 | -1
   9 | 0 |   | zero  |   3 | 3 | -3 |   2 | 2 |  2
   9 | 0 |   | zero  |   3 | 3 | -3 |   3 | 3 | -3
   9 | 0 |   | zero  |   3 | 3 | -3 |   4 | 2 |  4
   9 | 0 |   | zero  |   3 | 3 | -3 |   5 | 5 | -5
   9 | 0 |   | zero  |   3 | 3 | -3 |   6 | 5 | -5
   9 | 0 |   | zero  |   3 | 3 | -3 |   7 | 0 |   
   9 | 0 |   | zero  |   3 | 3 | -3 |   8 |   |   
   9 | 0 |   | zero  |   3 | 3 | -3 |   9 |   |  0
   9 | 0 |   | zero  |   4 | 2 |  4 |   1 | 1 | -1
   9 | 0 |   | zero  |   4 | 2 |  4 |   2 | 2 |  2
   9 | 0 |   | zero  |   4 | 2 |  4 |   3 | 3 | -3
   9 | 0 |   | zero  |   4 | 2 |  4 |   4 | 2 |  4
   9 | 0 |   | zero  |   4 | 2 |  4 |   5 | 5 | -5
   9 | 0 |   | zero  |   4 | 2 |  4 |   6 | 5 | -5
   9 | 0 |   | zero  |   4 | 2 |  4 |   7 | 0 |   
   9 | 0 |   | zero  |   4 | 2 |  4 |   8 |   |   
   9 | 0 |   | zero  |   4 | 2 |  4 |   9 |   |  0
   9 | 0 |   | zero  |   5 | 5 | -5 |   1 | 1 | -1
   9 | 0 |   | zero  |   5 | 5 | -5 |   2 | 2 |  2
   9 | 0 |   | zero  |   5 | 5 | -5 |   3 | 3 | -3
   9 | 0 |   | zero  |   5 | 5 | -5 |   4 | 2 |  4
   9 | 0 |   | zero  |   5 | 5 | -5 |   5 | 5 | -5
   9 | 0 |   | zero  |   5 | 5 | -5 |   6 | 5 | -5
   9 | 0 |   | zero  |   5 | 5 | -5 |   7 | 0 |   
   9 | 0 |   | zero  |   5 | 5 | -5 |   8 |   |   
   9 | 0 |   | zero  |   5 | 5 | -5 |   9 |   |  0
   9 | 0 |   | zero  |   6 | 5 | -5 |   1 | 1 | -1
   9 | 0 |   | zero  |   6 | 5 | -5 |   2 | 2 |  2
   9 | 0 |   | zero  |   6 | 5 | -5 |   3 | 3 | -3
   9 | 0 |   | zero  |   6 | 5 | -5 |   4 | 2 |  4
   9 | 0 |   | zero  |   6 | 5 | -5 |   5 | 5 | -5
   9 | 0 |   | zero  |   6 | 5 | -5 |   6 | 5 | -5
   9 | 0 |   | zero  |   6 | 5 | -5 |   7 | 0 |   
   9 | 0 |   | zero  |   6 | 5 | -5 |   8 |   |   
   9 | 0 |   | zero  |   6 | 5 | -5 |   9 |   |  0
   9 | 0 |   | zero  |   7 | 0 |    |   1 | 1 | -1
   9 | 0 |   | zero  |   7 | 0 |    |   2 | 2 |  2
   9 | 0 |   | zero  |   7 | 0 |    |   3 | 3 | -3
   9 | 0 |   | zero  |   7 | 0 |    |   4 | 2 |  4
   9 | 0 |   | zero  |   7 | 0 |    |   5 | 5 | -5
   9 | 0 |   | zero  |   7 | 0 |    |   6 | 5 | -5
   9 | 0 |   | zero  |   7 | 0 |    |   7 | 0 |   
   9 | 0 |   | zero  |   7 | 0 |    |   8 |   |   
   9 | 0 |   | zero  |   7 | 0 |    |   9 |   |  0
   9 | 0 |   | zero  |   8 |   |    |   1 | 1 | -1
   9 | 0 |   | zero  |   8 |   |    |   2 | 2 |  2
   9 | 0 |   | zero  |   8 |   |    |   3 | 3 | -3
   9 | 0 |   | zero  |   8 |   |    |   4 | 2 |  4
   9 | 0 |   | zero  |   8 |   |    |   5 | 5 | -5
   9 | 0 |   | zero  |   8 |   |    |   6 | 5 | -5
   9 | 0 |   | zero  |   8 |   |    |   7 | 0 |   
   9 | 0 |   | zero  |   8 |   |    |   8 |   |   
   9 | 0 |   | zero  |   8 |   |    |   9 |   |  0
   9 | 0 |   | zero  |   9 |   |  0 |   1 | 1 | -1
   9 | 0 |   | zero  |   9 |   |  0 |   2 | 2 |  2
   9 | 0 |   | zero  |   9 |   |  0 |   3 | 3 | -3
   9 | 0 |   | zero  |   9 |   |  0 |   4 | 2 |  4
   9 | 0 |   | zero  |   9 |   |  0 |   5 | 5 | -5
   9 | 0 |   | zero  |   9 |   |  0 |   6 | 5 | -5
   9 | 0 |   | zero  |   9 |   |  0 |   7 | 0 |   
   9 | 0 |   | zero  |   9 |   |  0 |   8 |   |   
   9 | 0 |   | zero  |   9 |   |  0 |   9 |   |  0
  10 |   |   | null  |   1 | 1 | -1 |   1 | 1 | -1
  10 |   |   | null  |   1 | 1 | -1 |   2 | 2 |  2
  10 |   |   | null  |   1 | 1 | -1 |   3 | 3 | -3
  10 |   |   | null  |   1 | 1 | -1 |   4 | 2 |  4
  10 |   |   | null  |   1 | 1 | -1 |   5 | 5 | -5
  10 |   |   | null  |   1 | 1 | -1 |   6 | 5 | -5
  10 |   |   | null  |   1 | 1 | -1 |   7 | 0 |   
  10 |   |   | null  |   1 | 1 | -1 |   8 |   |   
  10 |   |   | null  |   1 | 1 | -1 |   9 |   |  0
  10 |   |   | null  |   2 | 2 |  2 |   1 | 1 | -1
  10 |   |   | null  |   2 | 2 |  2 |   2 | 2 |  2
  10 |   |   | null  |   2 | 2 |  2 |   3 | 3 | -3
  10 |   |   | null  |   2 | 2 |  2 |   4 | 2 |  4
  10 |   |   | null  |   2 | 2 |  2 |   5 | 5 | -5
  10 |   |   | null  |   2 | 2 |  2 |   6 | 5 | -5
  10 |   |   | null  |   2 | 2 |  2 |   7 | 0 |   
  10 |   |   | null  |   2 | 2 |  2 |   8 |   |   
  10 |   |   | null  |   2 | 2 |  2 |   9 |   |  0
  10 |   |   | null  |   3 | 3 | -3 |   1 | 1 | -1
  10 |   |   | null  |   3 | 3 | -3 |   2 | 2 |  2
  10 |   |   | null  |   3 | 3 | -3 |   3 | 3 | -3
  10 |   |   | null  |   3 | 3 | -3 |   4 | 2 |  4
  10 |   |   | null  |   3 | 3 | -3 |   5 | 5 | -5
  10 |   |   | null  |   3 | 3 | -3 |   6 | 5 | -5
  10 |   |   | null  |   3 | 3 | -3 |   7 | 0 |   
  10 |   |   | null  |   3 | 3 | -3 |   8 |   |   
  10 |   |   | null  |   3 | 3 | -3 |   9 |   |  0
  10 |   |   | null  |   4 | 2 |  4 |   1 | 1 | -1
  10 |   |   | null  |   4 | 2 |  4 |   2 | 2 |  2
  10 |   |   | null  |   4 | 2 |  4 |   3 | 3 | -3
  10 |   |   | null  |   4 | 2 |  4 |   4 | 2 |  4
  10 |   |   | null  |   4 | 2 |  4 |   5 | 5 | -5
  10 |   |   | null  |   4 | 2 |  4 |   6 | 5 | -5
  10 |   |   | null  |   4 | 2 |  4 |   7 | 0 |   
  10 |   |   | null  |   4 | 2 |  4 |   8 |   |   
  10 |   |   | null  |   4 | 2 |  4 |   9 |   |  0
  10 |   |   | null  |   5 | 5 | -5 |   1 | 1 | -1
  10 |   |   | null  |   5 | 5 | -5 |   2 | 2 |  2
  10 |   |   | null  |   5 | 5 | -5 |   3 | 3 | -3
  10 |   |   | null  |   5 | 5 | -5 |   4 | 2 |  4
  10 |   |   | null  |   5 | 5 | -5 |   5 | 5 | -5
  10 |   |   | null  |   5 | 5 | -5 |   6 | 5 | -5
  10 |   |   | null  |   5 | 5 | -5 |   7 | 0 |   
  10 |   |   | null  |   5 | 5 | -5 |   8 |   |   
  10 |   |   | null  |   5 | 5 | -5 |   9 |   |  0
  10 |   |   | null  |   6 | 5 | -5 |   1 | 1 | -1
  10 |   |   | null  |   6 | 5 | -5 |   2 | 2 |  2
  10 |   |   | null  |   6 | 5 | -5 |   3 | 3 | -3
  10 |   |   | null  |   6 | 5 | -5 |   4 | 2 |  4
  10 |   |   | null  |   6 | 5 | -5 |   5 | 5 | -5
  10 |   |   | null  |   6 | 5 | -5 |   6 | 5 | -5
  10 |   |   | null  |   6 | 5 | -5 |   7 | 0 |   
  10 |   |   | null  |   6 | 5 | -5 |   8 |   |   
  10 |   |   | null  |   6 | 5 | -5 |   9 |   |  0
  10 |   |   | null  |   7 | 0 |    |   1 | 1 | -1
  10 |   |   | null  |   7 | 0 |    |   2 | 2 |  2
  10 |   |   | null  |   7 | 0 |    |   3 | 3 | -3
  10 |   |   | null  |   7 | 0 |    |   4 | 2 |  4
  10 |   |   | null  |   7 | 0 |    |   5 | 5 | -5
  10 |   |   | null  |   7 | 0 |    |   6 | 5 | -5
  10 |   |   | null  |   7 | 0 |    |   7 | 0 |   
  10 |   |   | null  |   7 | 0 |    |   8 |   |   
  10 |   |   | null  |   7 | 0 |    |   9 |   |  0
  10 |   |   | null  |   8 |   |    |   1 | 1 | -1
  10 |   |   | null  |   8 |   |    |   2 | 2 |  2
  10 |   |   | null  |   8 |   |    |   3 | 3 | -3
  10 |   |   | null  |   8 |   |    |   4 | 2 |  4
  10 |   |   | null  |   8 |   |    |   5 | 5 | -5
  10 |   |   | null  |   8 |   |    |   6 | 5 | -5
  10 |   |   | null  |   8 |   |    |   7 | 0 |   
  10 |   |   | null  |   8 |   |    |   8 |   |   
  10 |   |   | null  |   8 |   |    |   9 |   |  0
  10 |   |   | null  |   9 |   |  0 |   1 | 1 | -1
  10 |   |   | null  |   9 |   |  0 |   2 | 2 |  2
  10 |   |   | null  |   9 |   |  0 |   3 | 3 | -3
  10 |   |   | null  |   9 |   |  0 |   4 | 2 |  4
  10 |   |   | null  |   9 |   |  0 |   5 | 5 | -5
  10 |   |   | null  |   9 |   |  0 |   6 | 5 | -5
  10 |   |   | null  |   9 |   |  0 |   7 | 0 |   
  10 |   |   | null  |   9 |   |  0 |   8 |   |   
  10 |   |   | null  |   9 |   |  0 |   9 |   |  0
  11 |   | 0 | zero  |   1 | 1 | -1 |   1 | 1 | -1
  11 |   | 0 | zero  |   1 | 1 | -1 |   2 | 2 |  2
  11 |   | 0 | zero  |   1 | 1 | -1 |   3 | 3 | -3
  11 |   | 0 | zero  |   1 | 1 | -1 |   4 | 2 |  4
  11 |   | 0 | zero  |   1 | 1 | -1 |   5 | 5 | -5
  11 |   | 0 | zero  |   1 | 1 | -1 |   6 | 5 | -5
  11 |   | 0 | zero  |   1 | 1 | -1 |   7 | 0 |   
  11 |   | 0 | zero  |   1 | 1 | -1 |   8 |   |   
  11 |   | 0 | zero  |   1 | 1 | -1 |   9 |   |  0
  11 |   | 0 | zero  |   2 | 2 |  2 |   1 | 1 | -1
  11 |   | 0 | zero  |   2 | 2 |  2 |   2 | 2 |  2
  11 |   | 0 | zero  |   2 | 2 |  2 |   3 | 3 | -3
  11 |   | 0 | zero  |   2 | 2 |  2 |   4 | 2 |  4
  11 |   | 0 | zero  |   2 | 2 |  2 |   5 | 5 | -5
  11 |   | 0 | zero  |   2 | 2 |  2 |   6 | 5 | -5
  11 |   | 0 | zero  |   2 | 2 |  2 |   7 | 0 |   
  11 |   | 0 | zero  |   2 | 2 |  2 |   8 |   |   
  11 |   | 0 | zero  |   2 | 2 |  2 |   9 |   |  0
  11 |   | 0 | zero  |   3 | 3 | -3 |   1 | 1 | -1
  11 |   | 0 | zero  |   3 | 3 | -3 |   2 | 2 |  2
  11 |   | 0 | zero  |   3 | 3 | -3 |   3 | 3 | -3
  11 |   | 0 | zero  |   3 | 3 | -3 |   4 | 2 |  4
  11 |   | 0 | zero  |   3 | 3 | -3 |   5 | 5 | -5
  11 |   | 0 | zero  |   3 | 3 | -3 |   6 | 5 | -5
  11 |   | 0 | zero  |   3 | 3 | -3 |   7 | 0 |   
  11 |   | 0 | zero  |   3 | 3 | -3 |   8 |   |   
  11 |   | 0 | zero  |   3 | 3 | -3 |   9 |   |  0
  11 |   | 0 | zero  |   4 | 2 |  4 |   1 | 1 | -1
  11 |   | 0 | zero  |   4 | 2 |  4 |   2 | 2 |  2
  11 |   | 0 | zero  |   4 | 2 |  4 |   3 | 3 | -3
  11 |   | 0 | zero  |   4 | 2 |  4 |   4 | 2 |  4
  11 |   | 0 | zero  |   4 | 2 |  4 |   5 | 5 | -5
  11 |   | 0 | zero  |   4 | 2 |  4 |   6 | 5 | -5
  11 |   | 0 | zero  |   4 | 2 |  4 |   7 | 0 |   
  11 |   | 0 | zero  |   4 | 2 |  4 |   8 |   |   
  11 |   | 0 | zero  |   4 | 2 |  4 |   9 |   |  0
  11 |   | 0 | zero  |   5 | 5 | -5 |   1 | 1 | -1
  11 |   | 0 | zero  |   5 | 5 | -5 |   2 | 2 |  2
  11 |   | 0 | zero  |   5 | 5 | -5 |   3 | 3 | -3
  11 |   | 0 | zero  |   5 | 5 | -5 |   4 | 2 |  4
  11 |   | 0 | zero  |   5 | 5 | -5 |   5 | 5 | -5
  11 |   | 0 | zero  |   5 | 5 | -5 |   6 | 5 | -5
  11 |   | 0 | zero  |   5 | 5 | -5 |   7 | 0 |   
  11 |   | 0 | zero  |   5 | 5 | -5 |   8 |   |   
  11 |   | 0 | zero  |   5 | 5 | -5 |   9 |   |  0
  11 |   | 0 | zero  |   6 | 5 | -5 |   1 | 1 | -1
  11 |   | 0 | zero  |   6 | 5 | -5 |   2 | 2 |  2
  11 |   | 0 | zero  |   6 | 5 | -5 |   3 | 3 | -3
  11 |   | 0 | zero  |   6 | 5 | -5 |   4 | 2 |  4
  11 |   | 0 | zero  |   6 | 5 | -5 |   5 | 5 | -5
  11 |   | 0 | zero  |   6 | 5 | -5 |   6 | 5 | -5
  11 |   | 0 | zero  |   6 | 5 | -5 |   7 | 0 |   
  11 |   | 0 | zero  |   6 | 5 | -5 |   8 |   |   
  11 |   | 0 | zero  |   6 | 5 | -5 |   9 |   |  0
  11 |   | 0 | zero  |   7 | 0 |    |   1 | 1 | -1
  11 |   | 0 | zero  |   7 | 0 |    |   2 | 2 |  2
  11 |   | 0 | zero  |   7 | 0 |    |   3 | 3 | -3
  11 |   | 0 | zero  |   7 | 0 |    |   4 | 2 |  4
  11 |   | 0 | zero  |   7 | 0 |    |   5 | 5 | -5
  11 |   | 0 | zero  |   7 | 0 |    |   6 | 5 | -5
  11 |   | 0 | zero  |   7 | 0 |    |   7 | 0 |   
  11 |   | 0 | zero  |   7 | 0 |    |   8 |   |   
  11 |   | 0 | zero  |   7 | 0 |    |   9 |   |  0
  11 |   | 0 | zero  |   8 |   |    |   1 | 1 | -1
  11 |   | 0 | zero  |   8 |   |    |   2 | 2 |  2
  11 |   | 0 | zero  |   8 |   |    |   3 | 3 | -3
  11 |   | 0 | zero  |   8 |   |    |   4 | 2 |  4
  11 |   | 0 | zero  |   8 |   |    |   5 | 5 | -5
  11 |   | 0 | zero  |   8 |   |    |   6 | 5 | -5
  11 |   | 0 | zero  |   8 |   |    |   7 | 0 |   
  11 |   | 0 | zero  |   8 |   |    |   8 |   |   
  11 |   | 0 | zero  |   8 |   |    |   9 |   |  0
  11 |   | 0 | zero  |   9 |   |  0 |   1 | 1 | -1
  11 |   | 0 | zero  |   9 |   |  0 |   2 | 2 |  2
  11 |   | 0 | zero  |   9 |   |  0 |   3 | 3 | -3
  11 |   | 0 | zero  |   9 |   |  0 |   4 | 2 |  4
  11 |   | 0 | zero  |   9 |   |  0 |   5 | 5 | -5
  11 |   | 0 | zero  |   9 |   |  0 |   6 | 5 | -5
  11 |   | 0 | zero  |   9 |   |  0 |   7 | 0 |   
  11 |   | 0 | zero  |   9 |   |  0 |   8 |   |   
  11 |   | 0 | zero  |   9 |   |  0 |   9 |   |  0
(891 rows)

--
--
-- Inner joins (equi-joins)
--
--
--
-- Inner joins (equi-joins) with USING clause
-- The USING syntax changes the shape of the resulting table
-- by including a column in the USING clause only once in the result.
--
-- Inner equi-join on specified column
--Testcase 32:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL INNER JOIN J2_TBL USING (i);
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=99.66..179.66 rows=5000 width=52)
   Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
   Merge Cond: (j1_tbl.i = j2_tbl.i)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=44)
         Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t
         Sort Key: j1_tbl.i
         ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1000 width=44)
               Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t
               Foreign Namespace: join_regress.J1_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=12)
         Output: j2_tbl._id, j2_tbl.k, j2_tbl.i
         Sort Key: j2_tbl.i
         ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1000 width=12)
               Output: j2_tbl._id, j2_tbl.k, j2_tbl.i
               Foreign Namespace: join_regress.J2_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 33:
SELECT *
  FROM J1_TBL INNER JOIN J2_TBL USING (i);
 i | _id | j |   t   | _id | k  
---+-----+---+-------+-----+----
 0 |   9 |   | zero  |   7 |   
 1 |   1 | 4 | one   |   1 | -1
 2 |   2 | 3 | two   |   2 |  2
 2 |   2 | 3 | two   |   4 |  4
 3 |   3 | 2 | three |   3 | -3
 5 |   5 | 0 | five  |   5 | -5
 5 |   5 | 0 | five  |   6 | -5
(7 rows)

-- Same as above, slightly different syntax
--Testcase 34:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL JOIN J2_TBL USING (i);
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=99.66..179.66 rows=5000 width=52)
   Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
   Merge Cond: (j1_tbl.i = j2_tbl.i)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=44)
         Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t
         Sort Key: j1_tbl.i
         ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1000 width=44)
               Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t
               Foreign Namespace: join_regress.J1_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=12)
         Output: j2_tbl._id, j2_tbl.k, j2_tbl.i
         Sort Key: j2_tbl.i
         ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1000 width=12)
               Output: j2_tbl._id, j2_tbl.k, j2_tbl.i
               Foreign Namespace: join_regress.J2_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 35:
SELECT *
  FROM J1_TBL JOIN J2_TBL USING (i);
 i | _id | j |   t   | _id | k  
---+-----+---+-------+-----+----
 0 |   9 |   | zero  |   7 |   
 1 |   1 | 4 | one   |   1 | -1
 2 |   2 | 3 | two   |   2 |  2
 2 |   2 | 3 | two   |   4 |  4
 3 |   3 | 2 | three |   3 | -3
 5 |   5 | 0 | five  |   5 | -5
 5 |   5 | 0 | five  |   6 | -5
(7 rows)

--Testcase 36:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL t1 (id1, a, b, c) JOIN J2_TBL t2 (id2, a, d) USING (a)
  ORDER BY a, d;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Incremental Sort  (cost=101.04..448.49 rows=5000 width=52)
   Output: t1.a, t1.id1, t1.b, t1.c, t2.id2, t2.d
   Sort Key: t1.a, t2.d
   Presorted Key: t1.a
   ->  Merge Join  (cost=99.66..179.66 rows=5000 width=52)
         Output: t1.a, t1.id1, t1.b, t1.c, t2.id2, t2.d
         Merge Cond: (t1.a = t2.a)
         ->  Sort  (cost=49.83..52.33 rows=1000 width=44)
               Output: t1.a, t1.id1, t1.b, t1.c
               Sort Key: t1.a
               ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1000 width=44)
                     Output: t1.a, t1.id1, t1.b, t1.c
                     Foreign Namespace: join_regress.J1_TBL
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
         ->  Sort  (cost=49.83..52.33 rows=1000 width=12)
               Output: t2.id2, t2.d, t2.a
               Sort Key: t2.a
               ->  Foreign Scan on public.j2_tbl t2  (cost=0.00..0.00 rows=1000 width=12)
                     Output: t2.id2, t2.d, t2.a
                     Foreign Namespace: join_regress.J2_TBL
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(21 rows)

--Testcase 37:
SELECT *
  FROM J1_TBL t1 (id1, a, b, c) JOIN J2_TBL t2 (id2, a, d) USING (a)
  ORDER BY a, d;
 a | id1 | b |   c   | id2 | d  
---+-----+---+-------+-----+----
 0 |   9 |   | zero  |   7 |   
 1 |   1 | 4 | one   |   1 | -1
 2 |   2 | 3 | two   |   2 |  2
 2 |   2 | 3 | two   |   4 |  4
 3 |   3 | 2 | three |   3 | -3
 5 |   5 | 0 | five  |   5 | -5
 5 |   5 | 0 | five  |   6 | -5
(7 rows)

--Testcase 38:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL t1 (id1, a, b, c) JOIN J2_TBL t2 (id2, a, b) USING (b)
  ORDER BY b, t1.a;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Incremental Sort  (cost=101.04..448.49 rows=5000 width=52)
   Output: t1.b, t1.id1, t1.a, t1.c, t2.id2, t2.a
   Sort Key: t1.b, t1.a
   Presorted Key: t1.b
   ->  Merge Join  (cost=99.66..179.66 rows=5000 width=52)
         Output: t1.b, t1.id1, t1.a, t1.c, t2.id2, t2.a
         Merge Cond: (t1.b = t2.b)
         ->  Sort  (cost=49.83..52.33 rows=1000 width=44)
               Output: t1.b, t1.id1, t1.a, t1.c
               Sort Key: t1.b
               ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1000 width=44)
                     Output: t1.b, t1.id1, t1.a, t1.c
                     Foreign Namespace: join_regress.J1_TBL
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
         ->  Sort  (cost=49.83..52.33 rows=1000 width=12)
               Output: t2.id2, t2.a, t2.b
               Sort Key: t2.b
               ->  Foreign Scan on public.j2_tbl t2  (cost=0.00..0.00 rows=1000 width=12)
                     Output: t2.id2, t2.a, t2.b
                     Foreign Namespace: join_regress.J2_TBL
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(21 rows)

--Testcase 39:
SELECT *
  FROM J1_TBL t1 (id1, a, b, c) JOIN J2_TBL t2 (id2, a, b) USING (b)
  ORDER BY b, t1.a;
 b | id1 | a |   c   | id2 | a 
---+-----+---+-------+-----+---
 0 |   5 | 5 | five  |   9 |  
 0 |  11 |   | zero  |   9 |  
 2 |   3 | 3 | three |   2 | 2
 4 |   1 | 1 | one   |   4 | 2
(4 rows)

-- test join using aliases
SELECT * FROM J1_TBL JOIN J2_TBL USING (i) WHERE J1_TBL.t = 'one';  -- ok
 i | _id | j |  t  | _id | k  
---+-----+---+-----+-----+----
 1 |   1 | 4 | one |   1 | -1
(1 row)

SELECT * FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';  -- ok
 i | _id | j |  t  | _id | k  
---+-----+---+-----+-----+----
 1 |   1 | 4 | one |   1 | -1
(1 row)

SELECT * FROM (J1_TBL JOIN J2_TBL USING (i)) AS x WHERE J1_TBL.t = 'one';  -- error
ERROR:  invalid reference to FROM-clause entry for table "j1_tbl"
LINE 1: ... * FROM (J1_TBL JOIN J2_TBL USING (i)) AS x WHERE J1_TBL.t =...
                                                             ^
HINT:  There is an entry for table "j1_tbl", but it cannot be referenced from this part of the query.
SELECT * FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE x.i = 1;  -- ok
 i | _id | j |  t  | _id | k  
---+-----+---+-----+-----+----
 1 |   1 | 4 | one |   1 | -1
(1 row)

SELECT * FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE x.t = 'one';  -- error
ERROR:  column x.t does not exist
LINE 1: ...CT * FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE x.t = 'one...
                                                             ^
SELECT * FROM (J1_TBL JOIN J2_TBL USING (i) AS x) AS xx WHERE x.i = 1;  -- error (XXX could use better hint)
ERROR:  missing FROM-clause entry for table "x"
LINE 1: ...ROM (J1_TBL JOIN J2_TBL USING (i) AS x) AS xx WHERE x.i = 1;
                                                               ^
SELECT * FROM J1_TBL a1 JOIN J2_TBL a2 USING (i) AS a1;  -- error
ERROR:  table name "a1" specified more than once
SELECT x.* FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
 i 
---
 1
(1 row)

SELECT ROW(x.*) FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
 row 
-----
 (1)
(1 row)

SELECT row_to_json(x.*) FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
 row_to_json 
-------------
 {"i":1}
(1 row)

--
-- NATURAL JOIN
-- Inner equi-join on all columns with the same name
--
--Testcase 40:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL NATURAL JOIN J2_TBL;
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=99.66..114.91 rows=25 width=48)
   Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t, j2_tbl.k
   Merge Cond: ((j1_tbl._id = j2_tbl._id) AND (j1_tbl.i = j2_tbl.i))
   ->  Sort  (cost=49.83..52.33 rows=1000 width=44)
         Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t
         Sort Key: j1_tbl._id, j1_tbl.i
         ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1000 width=44)
               Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t
               Foreign Namespace: join_regress.J1_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=12)
         Output: j2_tbl.k, j2_tbl._id, j2_tbl.i
         Sort Key: j2_tbl._id, j2_tbl.i
         ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1000 width=12)
               Output: j2_tbl.k, j2_tbl._id, j2_tbl.i
               Foreign Namespace: join_regress.J2_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 41:
SELECT *
  FROM J1_TBL NATURAL JOIN J2_TBL;
 _id | i | j |   t   | k  
-----+---+---+-------+----
   1 | 1 | 4 | one   | -1
   2 | 2 | 3 | two   |  2
   3 | 3 | 2 | three | -3
   5 | 5 | 0 | five  | -5
(4 rows)

--Testcase 42:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL t1 (id1, a, b, c) NATURAL JOIN J2_TBL t2 (id2, a, d);
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=99.66..179.66 rows=5000 width=52)
   Output: t1.a, t1.id1, t1.b, t1.c, t2.id2, t2.d
   Merge Cond: (t1.a = t2.a)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=44)
         Output: t1.a, t1.id1, t1.b, t1.c
         Sort Key: t1.a
         ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1000 width=44)
               Output: t1.a, t1.id1, t1.b, t1.c
               Foreign Namespace: join_regress.J1_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=12)
         Output: t2.id2, t2.d, t2.a
         Sort Key: t2.a
         ->  Foreign Scan on public.j2_tbl t2  (cost=0.00..0.00 rows=1000 width=12)
               Output: t2.id2, t2.d, t2.a
               Foreign Namespace: join_regress.J2_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 43:
SELECT *
  FROM J1_TBL t1 (id1, a, b, c) NATURAL JOIN J2_TBL t2 (id2, a, d);
 a | id1 | b |   c   | id2 | d  
---+-----+---+-------+-----+----
 0 |   9 |   | zero  |   7 |   
 1 |   1 | 4 | one   |   1 | -1
 2 |   2 | 3 | two   |   2 |  2
 2 |   2 | 3 | two   |   4 |  4
 3 |   3 | 2 | three |   3 | -3
 5 |   5 | 0 | five  |   5 | -5
 5 |   5 | 0 | five  |   6 | -5
(7 rows)

--Testcase 44:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL t1 (id1, a, b, c) NATURAL JOIN J2_TBL t2 (id2, d, a);
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=99.66..179.66 rows=5000 width=52)
   Output: t1.a, t1.id1, t1.b, t1.c, t2.id2, t2.d
   Merge Cond: (t1.a = t2.a)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=44)
         Output: t1.a, t1.id1, t1.b, t1.c
         Sort Key: t1.a
         ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1000 width=44)
               Output: t1.a, t1.id1, t1.b, t1.c
               Foreign Namespace: join_regress.J1_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=12)
         Output: t2.id2, t2.d, t2.a
         Sort Key: t2.a
         ->  Foreign Scan on public.j2_tbl t2  (cost=0.00..0.00 rows=1000 width=12)
               Output: t2.id2, t2.d, t2.a
               Foreign Namespace: join_regress.J2_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 45:
SELECT *
  FROM J1_TBL t1 (id1, a, b, c) NATURAL JOIN J2_TBL t2 (id2, d, a);
 a | id1 | b |  c   | id2 | d 
---+-----+---+------+-----+---
 0 |   9 |   | zero |   9 |  
 2 |   2 | 3 | two  |   2 | 2
 4 |   4 | 1 | for  |   4 | 2
(3 rows)

-- mismatch number of columns
-- currently, Postgres will fill in with underlying names
--Testcase 46:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=99.66..179.66 rows=5000 width=52)
   Output: t1.a, t1.b, t1.j, t1.t, t2.i, t2.k
   Merge Cond: (t1.a = t2.a)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=44)
         Output: t1.a, t1.b, t1.j, t1.t
         Sort Key: t1.a
         ->  Foreign Scan on public.j1_tbl t1  (cost=0.00..0.00 rows=1000 width=44)
               Output: t1.a, t1.b, t1.j, t1.t
               Foreign Namespace: join_regress.J1_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=12)
         Output: t2.i, t2.k, t2.a
         Sort Key: t2.a
         ->  Foreign Scan on public.j2_tbl t2  (cost=0.00..0.00 rows=1000 width=12)
               Output: t2.i, t2.k, t2.a
               Foreign Namespace: join_regress.J2_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 47:
SELECT *
  FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);
 a | b | j |   t   | i | k  
---+---+---+-------+---+----
 1 | 1 | 4 | one   | 1 | -1
 2 | 2 | 3 | two   | 2 |  2
 3 | 3 | 2 | three | 3 | -3
 4 | 4 | 1 | for   | 2 |  4
 5 | 5 | 0 | five  | 5 | -5
 6 | 6 | 6 | six   | 5 | -5
 7 | 7 | 7 | seven | 0 |   
 8 | 8 | 8 | eight |   |   
 9 | 0 |   | zero  |   |  0
(9 rows)

--
-- Inner joins (equi-joins)
--
--Testcase 48:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=99.66..179.66 rows=5000 width=56)
   Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.i, j2_tbl.k
   Merge Cond: (j1_tbl.i = j2_tbl.i)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=44)
         Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t
         Sort Key: j1_tbl.i
         ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1000 width=44)
               Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t
               Foreign Namespace: join_regress.J1_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=12)
         Output: j2_tbl._id, j2_tbl.i, j2_tbl.k
         Sort Key: j2_tbl.i
         ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1000 width=12)
               Output: j2_tbl._id, j2_tbl.i, j2_tbl.k
               Foreign Namespace: join_regress.J2_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 49:
SELECT *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);
 _id | i | j |   t   | _id | i | k  
-----+---+---+-------+-----+---+----
   9 | 0 |   | zero  |   7 | 0 |   
   1 | 1 | 4 | one   |   1 | 1 | -1
   2 | 2 | 3 | two   |   2 | 2 |  2
   2 | 2 | 3 | two   |   4 | 2 |  4
   3 | 3 | 2 | three |   3 | 3 | -3
   5 | 5 | 0 | five  |   5 | 5 | -5
   5 | 5 | 0 | five  |   6 | 5 | -5
(7 rows)

--Testcase 50:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=99.66..179.66 rows=5000 width=56)
   Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.i, j2_tbl.k
   Merge Cond: (j1_tbl.i = j2_tbl.k)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=44)
         Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t
         Sort Key: j1_tbl.i
         ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1000 width=44)
               Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t
               Foreign Namespace: join_regress.J1_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=12)
         Output: j2_tbl._id, j2_tbl.i, j2_tbl.k
         Sort Key: j2_tbl.k
         ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1000 width=12)
               Output: j2_tbl._id, j2_tbl.i, j2_tbl.k
               Foreign Namespace: join_regress.J2_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 51:
SELECT *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);
 _id | i | j |  t   | _id | i | k 
-----+---+---+------+-----+---+---
   9 | 0 |   | zero |   9 |   | 0
   2 | 2 | 3 | two  |   2 | 2 | 2
   4 | 4 | 1 | for  |   4 | 2 | 4
(3 rows)

--
-- Non-equi-joins
--
--Testcase 52:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);
                                                                                         QUERY PLAN                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.00..12500.00 rows=333333 width=56)
   Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.i, j2_tbl.k
   Join Filter: (j1_tbl.i <= j2_tbl.k)
   ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1000 width=44)
         Output: j1_tbl._id, j1_tbl.i, j1_tbl.j, j1_tbl.t
         Foreign Namespace: join_regress.J1_TBL
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1000 width=12)
         Output: j2_tbl._id, j2_tbl.i, j2_tbl.k
         Foreign Namespace: join_regress.J2_TBL
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(11 rows)

--Testcase 53:
SELECT *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);
 _id | i | j |   t   | _id | i | k 
-----+---+---+-------+-----+---+---
   1 | 1 | 4 | one   |   2 | 2 | 2
   1 | 1 | 4 | one   |   4 | 2 | 4
   2 | 2 | 3 | two   |   2 | 2 | 2
   2 | 2 | 3 | two   |   4 | 2 | 4
   3 | 3 | 2 | three |   4 | 2 | 4
   4 | 4 | 1 | for   |   4 | 2 | 4
   9 | 0 |   | zero  |   2 | 2 | 2
   9 | 0 |   | zero  |   4 | 2 | 4
   9 | 0 |   | zero  |   9 |   | 0
(9 rows)

--
-- Outer joins
-- Note that OUTER is a noise word
--
--Testcase 54:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
                                                                                                                                                                                                                              QUERY PLAN                                                                                                                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=52)
   Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
   Sort Key: j1_tbl.i, j2_tbl.k, j1_tbl.t
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
         Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
         Foreign Namespace: join_regress.J1_TBL
         Query document: { "pipeline" : [ { "$lookup" : { "from" : "J2_TBL", "let" : { "ref2" : "$i" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref2", "$i" ] } } }, { "$project" : { "ref4" : "$_id", "ref5" : "$k" } } ], "as" : "J2_TBL" } }, { "$unwind" : { "path" : "$J2_TBL", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$i", "ref1" : "$_id", "ref2" : "$j", "ref3" : "$t", "J2_TBL" : { "$numberInt" : "1" } } } ] }
(7 rows)

--Testcase 55:
SELECT *
  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
 i | _id | j |   t   | _id | k  
---+-----+---+-------+-----+----
 0 |   9 |   | zero  |   7 |   
 1 |   1 | 4 | one   |   1 | -1
 2 |   2 | 3 | two   |   2 |  2
 2 |   2 | 3 | two   |   4 |  4
 3 |   3 | 2 | three |   3 | -3
 4 |   4 | 1 | for   |     |   
 5 |   5 | 0 | five  |   5 | -5
 5 |   5 | 0 | five  |   6 | -5
 6 |   6 | 6 | six   |     |   
 7 |   7 | 7 | seven |     |   
 8 |   8 | 8 | eight |     |   
   |  10 |   | null  |   9 |  0
   |  11 | 0 | zero  |   9 |  0
   |  10 |   | null  |   8 |   
   |  11 | 0 | zero  |   8 |   
(15 rows)

--Testcase 56:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
                                                                                                                                                                                                                              QUERY PLAN                                                                                                                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=0.01..0.02 rows=0 width=52)
   Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
   Sort Key: j1_tbl.i, j2_tbl.k, j1_tbl.t
   ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
         Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
         Foreign Namespace: join_regress.J1_TBL
         Query document: { "pipeline" : [ { "$lookup" : { "from" : "J2_TBL", "let" : { "ref2" : "$i" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref2", "$i" ] } } }, { "$project" : { "ref4" : "$_id", "ref5" : "$k" } } ], "as" : "J2_TBL" } }, { "$unwind" : { "path" : "$J2_TBL", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$i", "ref1" : "$_id", "ref2" : "$j", "ref3" : "$t", "J2_TBL" : { "$numberInt" : "1" } } } ] }
(7 rows)

--Testcase 57:
SELECT *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
 i | _id | j |   t   | _id | k  
---+-----+---+-------+-----+----
 0 |   9 |   | zero  |   7 |   
 1 |   1 | 4 | one   |   1 | -1
 2 |   2 | 3 | two   |   2 |  2
 2 |   2 | 3 | two   |   4 |  4
 3 |   3 | 2 | three |   3 | -3
 4 |   4 | 1 | for   |     |   
 5 |   5 | 0 | five  |   5 | -5
 5 |   5 | 0 | five  |   6 | -5
 6 |   6 | 6 | six   |     |   
 7 |   7 | 7 | seven |     |   
 8 |   8 | 8 | eight |     |   
   |  10 |   | null  |   9 |  0
   |  11 | 0 | zero  |   9 |  0
   |  10 |   | null  |   8 |   
   |  11 | 0 | zero  |   8 |   
(15 rows)

--Testcase 58:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);
                                                                                                                                                                                                                           QUERY PLAN                                                                                                                                                                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=52)
   Output: j2_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
   Foreign Namespace: join_regress.J1_TBL
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "J1_TBL", "let" : { "ref2" : "$i" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$i", "$$ref2" ] } } }, { "$project" : { "ref1" : "$_id", "ref2" : "$j", "ref3" : "$t" } } ], "as" : "J1_TBL" } }, { "$unwind" : { "path" : "$J1_TBL", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$i", "ref4" : "$_id", "ref5" : "$k", "J1_TBL" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 59:
SELECT *
  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);
 i | _id | j |   t   | _id | k  
---+-----+---+-------+-----+----
 1 |   1 | 4 | one   |   1 | -1
 2 |   2 | 3 | two   |   2 |  2
 3 |   3 | 2 | three |   3 | -3
 2 |   2 | 3 | two   |   4 |  4
 5 |   5 | 0 | five  |   5 | -5
 5 |   5 | 0 | five  |   6 | -5
 0 |   9 |   | zero  |   7 |   
   |  10 |   | null  |   8 |   
   |  11 | 0 | zero  |   8 |   
   |  10 |   | null  |   9 |  0
   |  11 | 0 | zero  |   9 |  0
(11 rows)

--Testcase 60:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);
                                                                                                                                                                                                                           QUERY PLAN                                                                                                                                                                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=52)
   Output: j2_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
   Foreign Namespace: join_regress.J1_TBL
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "J1_TBL", "let" : { "ref2" : "$i" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$i", "$$ref2" ] } } }, { "$project" : { "ref1" : "$_id", "ref2" : "$j", "ref3" : "$t" } } ], "as" : "J1_TBL" } }, { "$unwind" : { "path" : "$J1_TBL", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$i", "ref4" : "$_id", "ref5" : "$k", "J1_TBL" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 61:
SELECT *
  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);
 i | _id | j |   t   | _id | k  
---+-----+---+-------+-----+----
 1 |   1 | 4 | one   |   1 | -1
 2 |   2 | 3 | two   |   2 |  2
 3 |   3 | 2 | three |   3 | -3
 2 |   2 | 3 | two   |   4 |  4
 5 |   5 | 0 | five  |   5 | -5
 5 |   5 | 0 | five  |   6 | -5
 0 |   9 |   | zero  |   7 |   
   |  10 |   | null  |   8 |   
   |  11 | 0 | zero  |   8 |   
   |  10 |   | null  |   9 |  0
   |  11 | 0 | zero  |   9 |  0
(11 rows)

--Testcase 62:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=486.85..499.35 rows=5000 width=52)
   Output: (COALESCE(j1_tbl.i, j2_tbl.i)), j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
   Sort Key: (COALESCE(j1_tbl.i, j2_tbl.i)), j2_tbl.k, j1_tbl.t
   ->  Merge Full Join  (cost=99.66..179.66 rows=5000 width=52)
         Output: COALESCE(j1_tbl.i, j2_tbl.i), j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
         Merge Cond: (j1_tbl.i = j2_tbl.i)
         ->  Sort  (cost=49.83..52.33 rows=1000 width=44)
               Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t
               Sort Key: j1_tbl.i
               ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1000 width=44)
                     Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t
                     Foreign Namespace: join_regress.J1_TBL
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
         ->  Sort  (cost=49.83..52.33 rows=1000 width=12)
               Output: j2_tbl.i, j2_tbl._id, j2_tbl.k
               Sort Key: j2_tbl.i
               ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1000 width=12)
                     Output: j2_tbl.i, j2_tbl._id, j2_tbl.k
                     Foreign Namespace: join_regress.J2_TBL
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(20 rows)

--Testcase 63:
SELECT *
  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
 i | _id | j |   t   | _id | k  
---+-----+---+-------+-----+----
 0 |   9 |   | zero  |   7 |   
 1 |   1 | 4 | one   |   1 | -1
 2 |   2 | 3 | two   |   2 |  2
 2 |   2 | 3 | two   |   4 |  4
 3 |   3 | 2 | three |   3 | -3
 4 |   4 | 1 | for   |     |   
 5 |   5 | 0 | five  |   6 | -5
 5 |   5 | 0 | five  |   5 | -5
 6 |   6 | 6 | six   |     |   
 7 |   7 | 7 | seven |     |   
 8 |   8 | 8 | eight |     |   
   |     |   |       |   9 |  0
   |  10 |   | null  |     |   
   |  11 | 0 | zero  |     |   
   |     |   |       |   8 |   
(15 rows)

--Testcase 64:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL FULL JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=486.85..499.35 rows=5000 width=52)
   Output: (COALESCE(j1_tbl.i, j2_tbl.i)), j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
   Sort Key: (COALESCE(j1_tbl.i, j2_tbl.i)), j2_tbl.k, j1_tbl.t
   ->  Merge Full Join  (cost=99.66..179.66 rows=5000 width=52)
         Output: COALESCE(j1_tbl.i, j2_tbl.i), j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
         Merge Cond: (j1_tbl.i = j2_tbl.i)
         ->  Sort  (cost=49.83..52.33 rows=1000 width=44)
               Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t
               Sort Key: j1_tbl.i
               ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1000 width=44)
                     Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t
                     Foreign Namespace: join_regress.J1_TBL
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
         ->  Sort  (cost=49.83..52.33 rows=1000 width=12)
               Output: j2_tbl.i, j2_tbl._id, j2_tbl.k
               Sort Key: j2_tbl.i
               ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1000 width=12)
                     Output: j2_tbl.i, j2_tbl._id, j2_tbl.k
                     Foreign Namespace: join_regress.J2_TBL
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(20 rows)

--Testcase 65:
SELECT *
  FROM J1_TBL FULL JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
 i | _id | j |   t   | _id | k  
---+-----+---+-------+-----+----
 0 |   9 |   | zero  |   7 |   
 1 |   1 | 4 | one   |   1 | -1
 2 |   2 | 3 | two   |   2 |  2
 2 |   2 | 3 | two   |   4 |  4
 3 |   3 | 2 | three |   3 | -3
 4 |   4 | 1 | for   |     |   
 5 |   5 | 0 | five  |   6 | -5
 5 |   5 | 0 | five  |   5 | -5
 6 |   6 | 6 | six   |     |   
 7 |   7 | 7 | seven |     |   
 8 |   8 | 8 | eight |     |   
   |     |   |       |   9 |  0
   |  10 |   | null  |     |   
   |  11 | 0 | zero  |     |   
   |     |   |       |   8 |   
(15 rows)

--Testcase 66:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);
                                                                                                           QUERY PLAN                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=99.66..179.66 rows=5000 width=52)
   Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
   Merge Cond: (j1_tbl.i = j2_tbl.i)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=44)
         Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t
         Sort Key: j1_tbl.i
         ->  Foreign Scan on public.j1_tbl  (cost=0.00..0.00 rows=1000 width=44)
               Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t
               Foreign Namespace: join_regress.J1_TBL
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "j" : { "$numberInt" : "1" }, "t" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=12)
         Output: j2_tbl._id, j2_tbl.k, j2_tbl.i
         Sort Key: j2_tbl.i
         ->  Foreign Scan on public.j2_tbl  (cost=0.00..0.00 rows=1000 width=12)
               Output: j2_tbl._id, j2_tbl.k, j2_tbl.i
               Foreign Namespace: join_regress.J2_TBL
               Query document: { "pipeline" : [ { "$match" : { "k" : { "$eq" : { "$numberInt" : "1" } } } }, { "$project" : { "_id" : { "$numberInt" : "1" }, "i" : { "$numberInt" : "1" }, "k" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 67:
SELECT *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);
 i | _id | j | t | _id | k 
---+-----+---+---+-----+---
(0 rows)

--Testcase 68:
EXPLAIN VERBOSE SELECT *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);
                                                                                                                                                                                                                                                                                         QUERY PLAN                                                                                                                                                                                                                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
   Output: j1_tbl.i, j1_tbl._id, j1_tbl.j, j1_tbl.t, j2_tbl._id, j2_tbl.k
   Foreign Namespace: join_regress.J1_TBL
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "J2_TBL", "let" : { "ref2" : "$i" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$eq" : [ "$$ref2", "$i" ] }, { "$eq" : [ "$i", { "$numberInt" : "1" } ] } ] } } }, { "$project" : { "ref4" : "$_id", "ref5" : "$k" } } ], "as" : "J2_TBL" } }, { "$unwind" : { "path" : "$J2_TBL", "preserveNullAndEmptyArrays" : true } }, { "$match" : { "i" : { "$eq" : { "$numberInt" : "1" } } } }, { "$project" : { "ref0" : "$i", "ref1" : "$_id", "ref2" : "$j", "ref3" : "$t", "J2_TBL" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 69:
SELECT *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);
 i | _id | j |  t  | _id | k  
---+-----+---+-----+-----+----
 1 |   1 | 4 | one |   1 | -1
(1 row)

--
-- semijoin selectivity for <>
--
--Testcase 70:
CREATE FOREIGN TABLE tenk1 (
  _id 		int4,
  unique1   int4,
  unique2   int4,
  two       int4,
  four      int4,
  ten       int4,
  twenty    int4,
  hundred   int4,
  thousand  int4,
  twothousand int4,
  fivethous int4,
  tenthous  int4,
  odd       int4,
  even      int4,
  stringu1  name,
  stringu2  name,
  string4   name
) SERVER mongo_server OPTIONS (database 'join_regress', collection 'tenk');
--Testcase 71:
CREATE FOREIGN TABLE tenk2 (
  _id 		int4,
  unique1   int4,
  unique2   int4,
  two       int4,
  four      int4,
  ten       int4,
  twenty    int4,
  hundred   int4,
  thousand  int4,
  twothousand int4,
  fivethous int4,
  tenthous  int4,
  odd       int4,
  even      int4,
  stringu1  name,
  stringu2  name,
  string4   name
) SERVER mongo_server OPTIONS (database 'join_regress', collection 'tenk');
--Testcase 72:
CREATE FOREIGN TABLE int4_tbl (_id int4, f1 int4)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'int4_tbl');
--Testcase 73:
select * from int4_tbl;
 _id |     f1      
-----+-------------
   1 |           0
   2 |      123456
   3 |     -123456
   4 |  2147483647
   5 | -2147483647
(5 rows)

--Testcase 74:
explain (costs off)
select * from int4_tbl i4, tenk1 a
where exists(select * from tenk1 b
             where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)
      and i4.f1 = a.tenthous;
                           QUERY PLAN                           
----------------------------------------------------------------
 Hash Join
   Hash Cond: (i4.f1 = a.tenthous)
   ->  Foreign Scan on int4_tbl i4
         Foreign Namespace: join_regress.int4_tbl
   ->  Hash
         ->  Hash Semi Join
               Hash Cond: (a.twothousand = b.twothousand)
               Join Filter: (a.fivethous <> b.fivethous)
               ->  Foreign Scan on tenk1 a
                     Foreign Namespace: join_regress.tenk
               ->  Hash
                     ->  Foreign Scan on tenk1 b
                           Foreign Namespace: join_regress.tenk
(13 rows)

--
-- More complicated constructs
--
--
-- Multiway full join
--
--Testcase 75:
CREATE FOREIGN TABLE t1 (_id int4, name TEXT, n INTEGER)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 't1');
--Testcase 76:
CREATE FOREIGN TABLE t2 (_id int4, name TEXT, n INTEGER)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 't2');
--Testcase 77:
CREATE FOREIGN TABLE t3 (_id int4, name TEXT, n INTEGER)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 't3');
--Testcase 78:
EXPLAIN VERBOSE SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Full Join  (cost=536.68..916.68 rows=25000 width=56)
   Output: COALESCE(COALESCE(t1.name, t2.name), t3.name), t1._id, t1.n, t2._id, t2.n, t3._id, t3.n
   Merge Cond: (t3.name = (COALESCE(t1.name, t2.name)))
   ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
         Output: t3.name, t3._id, t3.n
         Sort Key: t3.name
         ->  Foreign Scan on public.t3  (cost=0.00..0.00 rows=1000 width=40)
               Output: t3.name, t3._id, t3.n
               Foreign Namespace: join_regress.t3
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=486.85..499.35 rows=5000 width=80)
         Output: t1.name, t1._id, t1.n, t2.name, t2._id, t2.n, (COALESCE(t1.name, t2.name))
         Sort Key: (COALESCE(t1.name, t2.name))
         ->  Merge Full Join  (cost=99.66..179.66 rows=5000 width=80)
               Output: t1.name, t1._id, t1.n, t2.name, t2._id, t2.n, COALESCE(t1.name, t2.name)
               Merge Cond: (t1.name = t2.name)
               ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
                     Output: t1.name, t1._id, t1.n
                     Sort Key: t1.name
                     ->  Foreign Scan on public.t1  (cost=0.00..0.00 rows=1000 width=40)
                           Output: t1.name, t1._id, t1.n
                           Foreign Namespace: join_regress.t1
                           Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
               ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
                     Output: t2.name, t2._id, t2.n
                     Sort Key: t2.name
                     ->  Foreign Scan on public.t2  (cost=0.00..0.00 rows=1000 width=40)
                           Output: t2.name, t2._id, t2.n
                           Foreign Namespace: join_regress.t2
                           Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
(30 rows)

--Testcase 79:
SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);
 name | _id | n  | _id | n  | _id | n  
------+-----+----+-----+----+-----+----
 bb   |   1 | 11 |   1 | 12 |   1 | 13
 cc   |     |    |   2 | 22 |   2 | 23
 dd   |     |    |     |    |   3 | 33
 ee   |     |    |   3 | 42 |     |   
(4 rows)

--
-- Test interactions of join syntax and subqueries
--
-- Basic cases (we expect planner to pull up the subquery here)
--Testcase 80:
EXPLAIN VERBOSE SELECT * FROM
(SELECT * FROM t2) as s2
INNER JOIN
(SELECT * FROM t3) s3
USING (name);
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=99.66..179.66 rows=5000 width=48)
   Output: t2.name, t2._id, t2.n, t3._id, t3.n
   Merge Cond: (t2.name = t3.name)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
         Output: t2.name, t2._id, t2.n
         Sort Key: t2.name
         ->  Foreign Scan on public.t2  (cost=0.00..0.00 rows=1000 width=40)
               Output: t2.name, t2._id, t2.n
               Foreign Namespace: join_regress.t2
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
         Output: t3._id, t3.n, t3.name
         Sort Key: t3.name
         ->  Foreign Scan on public.t3  (cost=0.00..0.00 rows=1000 width=40)
               Output: t3._id, t3.n, t3.name
               Foreign Namespace: join_regress.t3
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 81:
SELECT * FROM
(SELECT * FROM t2) as s2
INNER JOIN
(SELECT * FROM t3) s3
USING (name);
 name | _id | n  | _id | n  
------+-----+----+-----+----
 bb   |   1 | 12 |   1 | 13
 cc   |   2 | 22 |   2 | 23
(2 rows)

--Testcase 82:
EXPLAIN VERBOSE SELECT * FROM
(SELECT * FROM t2) as s2
LEFT JOIN
(SELECT * FROM t3) s3
USING (name);
                                                                                                                                                                                                                QUERY PLAN                                                                                                                                                                                                                
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
   Output: t2.name, t2._id, t2.n, t3._id, t3.n
   Foreign Namespace: join_regress.t2
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "t3", "let" : { "ref2" : "$name" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref2", "$name" ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$n" } } ], "as" : "t3" } }, { "$unwind" : { "path" : "$t3", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$name", "ref1" : "$_id", "ref2" : "$n", "t3" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 83:
SELECT * FROM
(SELECT * FROM t2) as s2
LEFT JOIN
(SELECT * FROM t3) s3
USING (name);
 name | _id | n  | _id | n  
------+-----+----+-----+----
 bb   |   1 | 12 |   1 | 13
 cc   |   2 | 22 |   2 | 23
 ee   |   3 | 42 |     |   
(3 rows)

--Testcase 84:
EXPLAIN VERBOSE SELECT * FROM
(SELECT * FROM t2) as s2
FULL JOIN
(SELECT * FROM t3) s3
USING (name);
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Full Join  (cost=99.66..179.66 rows=5000 width=48)
   Output: COALESCE(t2.name, t3.name), t2._id, t2.n, t3._id, t3.n
   Merge Cond: (t2.name = t3.name)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
         Output: t2.name, t2._id, t2.n
         Sort Key: t2.name
         ->  Foreign Scan on public.t2  (cost=0.00..0.00 rows=1000 width=40)
               Output: t2.name, t2._id, t2.n
               Foreign Namespace: join_regress.t2
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
         Output: t3.name, t3._id, t3.n
         Sort Key: t3.name
         ->  Foreign Scan on public.t3  (cost=0.00..0.00 rows=1000 width=40)
               Output: t3.name, t3._id, t3.n
               Foreign Namespace: join_regress.t3
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 85:
SELECT * FROM
(SELECT * FROM t2) as s2
FULL JOIN
(SELECT * FROM t3) s3
USING (name);
 name | _id | n  | _id | n  
------+-----+----+-----+----
 bb   |   1 | 12 |   1 | 13
 cc   |   2 | 22 |   2 | 23
 dd   |     |    |   3 | 33
 ee   |   3 | 42 |     |   
(4 rows)

-- Cases with non-nullable expressions in subquery results;
-- make sure these go to null as expected
--Testcase 86:
EXPLAIN VERBOSE SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL INNER JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=99.66..179.66 rows=5000 width=48)
   Output: t2.name, t2.n, 2, t3.n, 3
   Merge Cond: (t2.name = t3.name)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=36)
         Output: t2.name, t2.n
         Sort Key: t2.name
         ->  Foreign Scan on public.t2  (cost=0.00..0.00 rows=1000 width=36)
               Output: t2.name, t2.n
               Foreign Namespace: join_regress.t2
               Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=36)
         Output: t3.n, t3.name
         Sort Key: t3.name
         ->  Foreign Scan on public.t3  (cost=0.00..0.00 rows=1000 width=36)
               Output: t3.n, t3.name
               Foreign Namespace: join_regress.t3
               Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 87:
SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL INNER JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
 name | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------
 bb   |   12 |    2 |   13 |    3
 cc   |   22 |    2 |   23 |    3
(2 rows)

--Testcase 88:
EXPLAIN VERBOSE SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL LEFT JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Merge Left Join  (cost=99.66..179.66 rows=5000 width=48)
   Output: t2.name, t2.n, 2, t3.n, (3)
   Merge Cond: (t2.name = t3.name)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=36)
         Output: t2.name, t2.n
         Sort Key: t2.name
         ->  Foreign Scan on public.t2  (cost=0.00..0.00 rows=1000 width=36)
               Output: t2.name, t2.n
               Foreign Namespace: join_regress.t2
               Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
         Output: t3.n, t3.name, (3)
         Sort Key: t3.name
         ->  Foreign Scan on public.t3  (cost=0.00..0.00 rows=1000 width=40)
               Output: t3.n, t3.name, 3
               Foreign Namespace: join_regress.t3
               Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 89:
SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL LEFT JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
 name | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------
 bb   |   12 |    2 |   13 |    3
 cc   |   22 |    2 |   23 |    3
 ee   |   42 |    2 |      |     
(3 rows)

--Testcase 90:
EXPLAIN VERBOSE SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL FULL JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Merge Full Join  (cost=99.66..179.66 rows=5000 width=48)
   Output: COALESCE(t2.name, t3.name), t2.n, (2), t3.n, (3)
   Merge Cond: (t2.name = t3.name)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
         Output: t2.name, t2.n, (2)
         Sort Key: t2.name
         ->  Foreign Scan on public.t2  (cost=0.00..0.00 rows=1000 width=40)
               Output: t2.name, t2.n, 2
               Foreign Namespace: join_regress.t2
               Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
         Output: t3.name, t3.n, (3)
         Sort Key: t3.name
         ->  Foreign Scan on public.t3  (cost=0.00..0.00 rows=1000 width=40)
               Output: t3.name, t3.n, 3
               Foreign Namespace: join_regress.t3
               Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 91:
SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL FULL JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
 name | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------
 bb   |   12 |    2 |   13 |    3
 cc   |   22 |    2 |   23 |    3
 dd   |      |      |   33 |    3
 ee   |   42 |    2 |      |     
(4 rows)

--Testcase 92:
EXPLAIN VERBOSE SELECT * FROM
(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
NATURAL INNER JOIN
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL INNER JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Join  (cost=149.49..609.49 rows=25000 width=56)
   Output: t1.name, t1.n, 1, t2.n, 2, t3.n, 3
   Merge Cond: (t3.name = t1.name)
   ->  Sort  (cost=49.83..52.33 rows=1000 width=36)
         Output: t3.n, t3.name
         Sort Key: t3.name
         ->  Foreign Scan on public.t3  (cost=0.00..0.00 rows=1000 width=36)
               Output: t3.n, t3.name
               Foreign Namespace: join_regress.t3
               Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
   ->  Materialize  (cost=99.66..192.16 rows=5000 width=72)
         Output: t1.name, t1.n, t2.n, t2.name
         ->  Merge Join  (cost=99.66..179.66 rows=5000 width=72)
               Output: t1.name, t1.n, t2.n, t2.name
               Merge Cond: (t1.name = t2.name)
               ->  Sort  (cost=49.83..52.33 rows=1000 width=36)
                     Output: t1.name, t1.n
                     Sort Key: t1.name
                     ->  Foreign Scan on public.t1  (cost=0.00..0.00 rows=1000 width=36)
                           Output: t1.name, t1.n
                           Foreign Namespace: join_regress.t1
                           Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
               ->  Sort  (cost=49.83..52.33 rows=1000 width=36)
                     Output: t2.n, t2.name
                     Sort Key: t2.name
                     ->  Foreign Scan on public.t2  (cost=0.00..0.00 rows=1000 width=36)
                           Output: t2.n, t2.name
                           Foreign Namespace: join_regress.t2
                           Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
(29 rows)

--Testcase 93:
SELECT * FROM
(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
NATURAL INNER JOIN
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL INNER JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
 name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------+------+------
 bb   |   11 |    1 |   12 |    2 |   13 |    3
(1 row)

--Testcase 94:
EXPLAIN VERBOSE SELECT * FROM
(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
NATURAL FULL JOIN
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL FULL JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Full Join  (cost=536.68..916.68 rows=25000 width=56)
   Output: COALESCE(COALESCE(t1.name, t2.name), t3.name), t1.n, (1), t2.n, (2), t3.n, (3)
   Merge Cond: (t3.name = (COALESCE(t1.name, t2.name)))
   ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
         Output: t3.name, t3.n, (3)
         Sort Key: t3.name
         ->  Foreign Scan on public.t3  (cost=0.00..0.00 rows=1000 width=40)
               Output: t3.name, t3.n, 3
               Foreign Namespace: join_regress.t3
               Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=486.85..499.35 rows=5000 width=80)
         Output: t1.name, t1.n, t2.name, t2.n, (1), (2), (COALESCE(t1.name, t2.name))
         Sort Key: (COALESCE(t1.name, t2.name))
         ->  Merge Full Join  (cost=99.66..179.66 rows=5000 width=80)
               Output: t1.name, t1.n, t2.name, t2.n, (1), (2), COALESCE(t1.name, t2.name)
               Merge Cond: (t1.name = t2.name)
               ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
                     Output: t1.name, t1.n, (1)
                     Sort Key: t1.name
                     ->  Foreign Scan on public.t1  (cost=0.00..0.00 rows=1000 width=40)
                           Output: t1.name, t1.n, 1
                           Foreign Namespace: join_regress.t1
                           Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
               ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
                     Output: t2.name, t2.n, (2)
                     Sort Key: t2.name
                     ->  Foreign Scan on public.t2  (cost=0.00..0.00 rows=1000 width=40)
                           Output: t2.name, t2.n, 2
                           Foreign Namespace: join_regress.t2
                           Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
(30 rows)

--Testcase 95:
SELECT * FROM
(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
NATURAL FULL JOIN
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL FULL JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
 name | s1_n | s1_1 | s2_n | s2_2 | s3_n | s3_2 
------+------+------+------+------+------+------
 bb   |   11 |    1 |   12 |    2 |   13 |    3
 cc   |      |      |   22 |    2 |   23 |    3
 dd   |      |      |      |      |   33 |    3
 ee   |      |      |   42 |    2 |      |     
(4 rows)

--Testcase 96:
EXPLAIN VERBOSE SELECT * FROM
(SELECT name, n as s1_n FROM t1) as s1
NATURAL FULL JOIN
  (SELECT * FROM
    (SELECT name, n as s2_n FROM t2) as s2
    NATURAL FULL JOIN
    (SELECT name, n as s3_n FROM t3) as s3
  ) ss2;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Full Join  (cost=536.68..916.68 rows=25000 width=44)
   Output: COALESCE(t1.name, (COALESCE(t2.name, t3.name))), t1.n, t2.n, t3.n
   Merge Cond: (t1.name = (COALESCE(t2.name, t3.name)))
   ->  Sort  (cost=49.83..52.33 rows=1000 width=36)
         Output: t1.name, t1.n
         Sort Key: t1.name
         ->  Foreign Scan on public.t1  (cost=0.00..0.00 rows=1000 width=36)
               Output: t1.name, t1.n
               Foreign Namespace: join_regress.t1
               Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=486.85..499.35 rows=5000 width=40)
         Output: t2.n, t3.n, (COALESCE(t2.name, t3.name))
         Sort Key: (COALESCE(t2.name, t3.name))
         ->  Merge Full Join  (cost=99.66..179.66 rows=5000 width=40)
               Output: t2.n, t3.n, COALESCE(t2.name, t3.name)
               Merge Cond: (t2.name = t3.name)
               ->  Sort  (cost=49.83..52.33 rows=1000 width=36)
                     Output: t2.n, t2.name
                     Sort Key: t2.name
                     ->  Foreign Scan on public.t2  (cost=0.00..0.00 rows=1000 width=36)
                           Output: t2.n, t2.name
                           Foreign Namespace: join_regress.t2
                           Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
               ->  Sort  (cost=49.83..52.33 rows=1000 width=36)
                     Output: t3.n, t3.name
                     Sort Key: t3.name
                     ->  Foreign Scan on public.t3  (cost=0.00..0.00 rows=1000 width=36)
                           Output: t3.n, t3.name
                           Foreign Namespace: join_regress.t3
                           Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
(30 rows)

--Testcase 97:
SELECT * FROM
(SELECT name, n as s1_n FROM t1) as s1
NATURAL FULL JOIN
  (SELECT * FROM
    (SELECT name, n as s2_n FROM t2) as s2
    NATURAL FULL JOIN
    (SELECT name, n as s3_n FROM t3) as s3
  ) ss2;
 name | s1_n | s2_n | s3_n 
------+------+------+------
 bb   |   11 |   12 |   13
 cc   |      |   22 |   23
 dd   |      |      |   33
 ee   |      |   42 |     
(4 rows)

--Testcase 98:
EXPLAIN VERBOSE SELECT * FROM
(SELECT name, n as s1_n FROM t1) as s1
NATURAL FULL JOIN
  (SELECT * FROM
    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
    NATURAL FULL JOIN
    (SELECT name, n as s3_n FROM t3) as s3
  ) ss2;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Merge Full Join  (cost=536.68..916.68 rows=25000 width=48)
   Output: COALESCE(t1.name, (COALESCE(t2.name, t3.name))), t1.n, t2.n, (2), t3.n
   Merge Cond: (t1.name = (COALESCE(t2.name, t3.name)))
   ->  Sort  (cost=49.83..52.33 rows=1000 width=36)
         Output: t1.name, t1.n
         Sort Key: t1.name
         ->  Foreign Scan on public.t1  (cost=0.00..0.00 rows=1000 width=36)
               Output: t1.name, t1.n
               Foreign Namespace: join_regress.t1
               Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=486.85..499.35 rows=5000 width=44)
         Output: t2.n, t3.n, (COALESCE(t2.name, t3.name)), (2)
         Sort Key: (COALESCE(t2.name, t3.name))
         ->  Merge Full Join  (cost=99.66..179.66 rows=5000 width=44)
               Output: t2.n, t3.n, COALESCE(t2.name, t3.name), (2)
               Merge Cond: (t2.name = t3.name)
               ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
                     Output: t2.n, t2.name, (2)
                     Sort Key: t2.name
                     ->  Foreign Scan on public.t2  (cost=0.00..0.00 rows=1000 width=40)
                           Output: t2.n, t2.name, 2
                           Foreign Namespace: join_regress.t2
                           Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
               ->  Sort  (cost=49.83..52.33 rows=1000 width=36)
                     Output: t3.n, t3.name
                     Sort Key: t3.name
                     ->  Foreign Scan on public.t3  (cost=0.00..0.00 rows=1000 width=36)
                           Output: t3.n, t3.name
                           Foreign Namespace: join_regress.t3
                           Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
(30 rows)

--Testcase 99:
SELECT * FROM
(SELECT name, n as s1_n FROM t1) as s1
NATURAL FULL JOIN
  (SELECT * FROM
    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
    NATURAL FULL JOIN
    (SELECT name, n as s3_n FROM t3) as s3
  ) ss2;
 name | s1_n | s2_n | s2_2 | s3_n 
------+------+------+------+------
 bb   |   11 |   12 |    2 |   13
 cc   |      |   22 |    2 |   23
 dd   |      |      |      |   33
 ee   |      |   42 |    2 |     
(4 rows)

-- Constants as join keys can also be problematic
--Testcase 100:
EXPLAIN VERBOSE SELECT * FROM
  (SELECT name, n as s1_n FROM t1) as s1
FULL JOIN
  (SELECT name, 2 as s2_n FROM t2) as s2
ON (s1_n = s2_n);
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Merge Full Join  (cost=99.66..179.66 rows=5000 width=72)
   Output: t1.name, t1.n, t2.name, (2)
   Merge Cond: (t1.n = (2))
   ->  Sort  (cost=49.83..52.33 rows=1000 width=36)
         Output: t1.name, t1.n
         Sort Key: t1.n
         ->  Foreign Scan on public.t1  (cost=0.00..0.00 rows=1000 width=36)
               Output: t1.name, t1.n
               Foreign Namespace: join_regress.t1
               Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "n" : { "$numberInt" : "1" } } } ] }
   ->  Sort  (cost=49.83..52.33 rows=1000 width=36)
         Output: t2.name, (2)
         Sort Key: (2)
         ->  Foreign Scan on public.t2  (cost=0.00..0.00 rows=1000 width=36)
               Output: t2.name, 2
               Foreign Namespace: join_regress.t2
               Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" } } } ] }
(17 rows)

--Testcase 101:
SELECT * FROM
  (SELECT name, n as s1_n FROM t1) as s1
FULL JOIN
  (SELECT name, 2 as s2_n FROM t2) as s2
ON (s1_n = s2_n);
 name | s1_n | name | s2_n 
------+------+------+------
      |      | bb   |    2
      |      | cc   |    2
      |      | ee   |    2
 bb   |   11 |      |     
(4 rows)

-- Test for propagation of nullability constraints into sub-joins
--Testcase 102:
CREATE FOREIGN TABLE x (_id int4, x1 int, x2 int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'x');
--Testcase 103:
CREATE FOREIGN TABLE y (_id int4, y1 int, y2 int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'y');
--Testcase 104:
select * from x;
 _id | x1 | x2 
-----+----+----
   1 |  1 | 11
   2 |  2 | 22
   3 |  3 |   
   4 |  4 | 44
   5 |  5 |   
(5 rows)

--Testcase 105:
select * from y;
 _id | y1 | y2  
-----+----+-----
   1 |  1 | 111
   2 |  2 | 222
   3 |  3 | 333
   4 |  4 |    
(4 rows)

--Testcase 106:
EXPLAIN VERBOSE select * from x left join y on (x1 = y1 and x2 is not null);
                                                                                                                                                                                                                                                    QUERY PLAN                                                                                                                                                                                                                                                    
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2
   Foreign Namespace: join_regress.x
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref3" : "$x2", "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$ne" : [ "$ref3", null ] }, { "$eq" : [ "$$ref2", "$y1" ] } ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 107:
select * from x left join y on (x1 = y1 and x2 is not null);
 _id | x1 | x2 | _id | y1 | y2  
-----+----+----+-----+----+-----
   1 |  1 | 11 |   1 |  1 | 111
   2 |  2 | 22 |   2 |  2 | 222
   3 |  3 |    |   3 |  3 | 333
   4 |  4 | 44 |   4 |  4 |    
   5 |  5 |    |     |    |    
(5 rows)

--Testcase 108:
EXPLAIN VERBOSE select * from x left join y on (x1 = y1 and y2 is not null);
                                                                                                                                                                                                                                           QUERY PLAN                                                                                                                                                                                                                                           
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2
   Foreign Namespace: join_regress.x
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$eq" : [ "$$ref2", "$y1" ] }, { "$ne" : [ "$y2", null ] } ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 109:
select * from x left join y on (x1 = y1 and y2 is not null);
 _id | x1 | x2 | _id | y1 | y2  
-----+----+----+-----+----+-----
   1 |  1 | 11 |   1 |  1 | 111
   2 |  2 | 22 |   2 |  2 | 222
   3 |  3 |    |   3 |  3 | 333
   4 |  4 | 44 |     |    |    
   5 |  5 |    |     |    |    
(5 rows)

--Testcase 110:
EXPLAIN VERBOSE select * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
on (x1 = xx1);select * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
                                                                                                                                                                                                                                                                                                                                                                                      QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2, xx.idx, xx.xx1, xx.xx2
   Foreign Namespace: join_regress.x
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref2", "$y1" ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$lookup" : { "from" : "x", "let" : { "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref2", "$x1" ] } } }, { "$project" : { "ref6" : "$_id", "ref7" : "$x1", "ref8" : "$x2" } } ], "as" : "x" } }, { "$unwind" : { "path" : "$x", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" }, "x" : { "$numberInt" : "1" } } } ] }
(4 rows)

on (x1 = xx1);
 _id | x1 | x2 | _id | y1 | y2  | idx | xx1 | xx2 
-----+----+----+-----+----+-----+-----+-----+-----
   1 |  1 | 11 |   1 |  1 | 111 |   1 |   1 |  11
   2 |  2 | 22 |   2 |  2 | 222 |   2 |   2 |  22
   3 |  3 |    |   3 |  3 | 333 |   3 |   3 |    
   4 |  4 | 44 |   4 |  4 |     |   4 |   4 |  44
   5 |  5 |    |     |    |     |   5 |   5 |    
(5 rows)

--Testcase 111:
EXPLAIN VERBOSE select * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
on (x1 = xx1 and x2 is not null);
                                                                                                                                                                                                                                                                                                                                                                                                                      QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2, xx.idx, xx.xx1, xx.xx2
   Foreign Namespace: join_regress.x
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref2", "$y1" ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$lookup" : { "from" : "x", "let" : { "ref3" : "$x2", "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$ne" : [ "$ref3", null ] }, { "$eq" : [ "$$ref2", "$x1" ] } ] } } }, { "$project" : { "ref6" : "$_id", "ref7" : "$x1", "ref8" : "$x2" } } ], "as" : "x" } }, { "$unwind" : { "path" : "$x", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" }, "x" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 112:
select * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
on (x1 = xx1 and x2 is not null);
 _id | x1 | x2 | _id | y1 | y2  | idx | xx1 | xx2 
-----+----+----+-----+----+-----+-----+-----+-----
   1 |  1 | 11 |   1 |  1 | 111 |   1 |   1 |  11
   2 |  2 | 22 |   2 |  2 | 222 |   2 |   2 |  22
   3 |  3 |    |   3 |  3 | 333 |   3 |   3 |    
   4 |  4 | 44 |   4 |  4 |     |   4 |   4 |  44
   5 |  5 |    |     |    |     |   5 |   5 |    
(5 rows)

--Testcase 113:
EXPLAIN VERBOSE select * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
on (x1 = xx1 and y2 is not null);
                                                                                                                                                                                                                                                                                                                                                                                                                      QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2, xx.idx, xx.xx1, xx.xx2
   Foreign Namespace: join_regress.x
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref2", "$y1" ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$lookup" : { "from" : "x", "let" : { "ref3" : "$y2", "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$ne" : [ "$ref3", null ] }, { "$eq" : [ "$$ref2", "$x1" ] } ] } } }, { "$project" : { "ref6" : "$_id", "ref7" : "$x1", "ref8" : "$x2" } } ], "as" : "x" } }, { "$unwind" : { "path" : "$x", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" }, "x" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 114:
select * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
on (x1 = xx1 and y2 is not null);
 _id | x1 | x2 | _id | y1 | y2  | idx | xx1 | xx2 
-----+----+----+-----+----+-----+-----+-----+-----
   1 |  1 | 11 |   1 |  1 | 111 |   1 |   1 |  11
   2 |  2 | 22 |   2 |  2 | 222 |   2 |   2 |  22
   3 |  3 |    |   3 |  3 | 333 |   3 |   3 |    
   4 |  4 | 44 |   4 |  4 |     |   4 |   4 |  44
   5 |  5 |    |     |    |     |   5 |   5 |    
(5 rows)

--Testcase 115:
EXPLAIN VERBOSE select * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
on (x1 = xx1 and xx2 is not null);
                                                                                                                                                                                                                                                                                                                                                                                                             QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                              
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2, xx.idx, xx.xx1, xx.xx2
   Foreign Namespace: join_regress.x
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref2", "$y1" ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$lookup" : { "from" : "x", "let" : { "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$eq" : [ "$$ref2", "$x1" ] }, { "$ne" : [ "$x2", null ] } ] } } }, { "$project" : { "ref6" : "$_id", "ref7" : "$x1", "ref8" : "$x2" } } ], "as" : "x" } }, { "$unwind" : { "path" : "$x", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" }, "x" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 116:
select * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
on (x1 = xx1 and xx2 is not null);
 _id | x1 | x2 | _id | y1 | y2  | idx | xx1 | xx2 
-----+----+----+-----+----+-----+-----+-----+-----
   1 |  1 | 11 |   1 |  1 | 111 |   1 |   1 |  11
   2 |  2 | 22 |   2 |  2 | 222 |   2 |   2 |  22
   3 |  3 |    |   3 |  3 | 333 |     |     |    
   4 |  4 | 44 |   4 |  4 |     |   4 |   4 |  44
   5 |  5 |    |     |    |     |     |     |    
(5 rows)

-- these should NOT give the same answers as above
sEXPLAIN VERBOSE elect * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
on (x1 = xx1) where (x2 is not null);
ERROR:  syntax error at or near "sEXPLAIN"
LINE 1: sEXPLAIN VERBOSE elect * from (x left join y on (x1 = y1)) l...
        ^
--Testcase 117:
select * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
on (x1 = xx1) where (x2 is not null);
 _id | x1 | x2 | _id | y1 | y2  | idx | xx1 | xx2 
-----+----+----+-----+----+-----+-----+-----+-----
   1 |  1 | 11 |   1 |  1 | 111 |   1 |   1 |  11
   2 |  2 | 22 |   2 |  2 | 222 |   2 |   2 |  22
   4 |  4 | 44 |   4 |  4 |     |   4 |   4 |  44
(3 rows)

--Testcase 118:
EXPLAIN VERBOSE select * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
on (x1 = xx1) where (y2 is not null);
                                                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=0.00..3.76 rows=25000 width=36)
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2, xx.idx, xx.xx1, xx.xx2
   Hash Cond: (y.y1 = x.x1)
   ->  Foreign Scan on public.y  (cost=0.00..0.00 rows=1000 width=12)
         Output: y._id, y.y1, y.y2
         Foreign Namespace: join_regress.y
         Query document: { "pipeline" : [ { "$match" : { "y2" : { "$ne" : null } } }, { "$project" : { "_id" : { "$numberInt" : "1" }, "y1" : { "$numberInt" : "1" }, "y2" : { "$numberInt" : "1" } } } ] }
   ->  Hash  (cost=0.00..0.00 rows=0 width=0)
         Output: x._id, x.x1, x.x2, xx.idx, xx.xx1, xx.xx2
         ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
               Output: x._id, x.x1, x.x2, xx.idx, xx.xx1, xx.xx2
               Foreign Namespace: join_regress.x
               Query document: { "pipeline" : [ { "$lookup" : { "from" : "x", "let" : { "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref2", "$x1" ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$x1", "ref5" : "$x2" } } ], "as" : "x" } }, { "$unwind" : { "path" : "$x", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "x" : { "$numberInt" : "1" } } } ] }
(13 rows)

--Testcase 119:
select * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
on (x1 = xx1) where (y2 is not null);
 _id | x1 | x2 | _id | y1 | y2  | idx | xx1 | xx2 
-----+----+----+-----+----+-----+-----+-----+-----
   1 |  1 | 11 |   1 |  1 | 111 |   1 |   1 |  11
   2 |  2 | 22 |   2 |  2 | 222 |   2 |   2 |  22
   3 |  3 |    |   3 |  3 | 333 |   3 |   3 |    
(3 rows)

--Testcase 120:
EXPLAIN VERBOSE select * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
on (x1 = xx1) where (xx2 is not null);
                                                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Join  (cost=0.00..3.76 rows=1 width=36)
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2, xx.idx, xx.xx1, xx.xx2
   Hash Cond: (xx.xx1 = x.x1)
   ->  Foreign Scan on public.x xx  (cost=0.00..0.00 rows=1000 width=12)
         Output: xx.idx, xx.xx1, xx.xx2
         Foreign Namespace: join_regress.x
         Query document: { "pipeline" : [ { "$match" : { "x2" : { "$ne" : null } } }, { "$project" : { "_id" : { "$numberInt" : "1" }, "x1" : { "$numberInt" : "1" }, "x2" : { "$numberInt" : "1" } } } ] }
   ->  Hash  (cost=0.00..0.00 rows=0 width=0)
         Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2
         ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
               Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2
               Foreign Namespace: join_regress.x
               Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref2", "$y1" ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" } } } ] }
(13 rows)

--Testcase 121:
select * from (x left join y on (x1 = y1)) left join x xx(idx, xx1,xx2)
on (x1 = xx1) where (xx2 is not null);
 _id | x1 | x2 | _id | y1 | y2  | idx | xx1 | xx2 
-----+----+----+-----+----+-----+-----+-----+-----
   1 |  1 | 11 |   1 |  1 | 111 |   1 |   1 |  11
   2 |  2 | 22 |   2 |  2 | 222 |   2 |   2 |  22
   4 |  4 | 44 |   4 |  4 |     |   4 |   4 |  44
(3 rows)

--
-- regression test: check handling of empty-FROM subquery underneath outer join
--
--Testcase 122:
CREATE FOREIGN TABLE int8_tbl (_id int4, q1 int8, q2 int8)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'int8_tbl');
--Testcase 123:
explain (costs off)
select * from int8_tbl i1 left join (int8_tbl i2 join
  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2
order by 1, 2;
                          QUERY PLAN                          
--------------------------------------------------------------
 Sort
   Sort Key: i1._id, i1.q1
   ->  Merge Left Join
         Merge Cond: (i1.q2 = i2.q2)
         ->  Sort
               Sort Key: i1.q2
               ->  Foreign Scan on int8_tbl i1
                     Foreign Namespace: join_regress.int8_tbl
         ->  Sort
               Sort Key: i2.q2
               ->  Foreign Scan on int8_tbl i2
                     Foreign Namespace: join_regress.int8_tbl
(12 rows)

--Testcase 124:
select * from int8_tbl i1 left join (int8_tbl i2 join
  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2
order by 1, 2;
 _id |        q1        |        q2         | _id | q1  |        q2        |  x  
-----+------------------+-------------------+-----+-----+------------------+-----
   1 |              123 |               456 |   1 | 123 |              456 | 123
   2 |              123 |  4567890123456789 |   2 | 123 | 4567890123456789 | 123
   3 | 4567890123456789 |               123 |     |     |                  |    
   4 | 4567890123456789 |  4567890123456789 |   2 | 123 | 4567890123456789 | 123
   5 | 4567890123456789 | -4567890123456789 |     |     |                  |    
(5 rows)

--
-- regression test for 8.1 merge right join bug
--
--Testcase 125:
CREATE FOREIGN TABLE tt1 (_id int4, tt1_id int4, joincol int4)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'tt1');
--Testcase 126:
CREATE FOREIGN TABLE tt2 (_id int4, tt2_id int4, joincol int4)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'tt2');
--Testcase 127:
set enable_hashjoin to off;
--Testcase 128:
set enable_nestloop to off;
-- these should give the same results
--Testcase 129:
EXPLAIN VERBOSE select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;
                                                                                                                                                                                                                                      QUERY PLAN                                                                                                                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
   Output: tt1._id, tt1.tt1_id, tt1.joincol, tt2._id, tt2.tt2_id, tt2.joincol
   Foreign Namespace: join_regress.tt1
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "tt2", "let" : { "ref3" : "$joincol" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref3", "$joincol" ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$tt2_id", "ref5" : "$joincol" } } ], "as" : "tt2" } }, { "$unwind" : { "path" : "$tt2", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$tt1_id", "ref2" : "$joincol", "tt2" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 130:
select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;
 _id | tt1_id | joincol | _id | tt2_id | joincol 
-----+--------+---------+-----+--------+---------
   1 |      1 |      11 |   1 |     21 |      11
   1 |      1 |      11 |   2 |     21 |      11
   2 |      2 |         |     |        |        
(3 rows)

--Testcase 131:
EXPLAIN VERBOSE select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;
                                                                                                                                                                                                                                      QUERY PLAN                                                                                                                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
   Output: tt1._id, tt1.tt1_id, tt1.joincol, tt2._id, tt2.tt2_id, tt2.joincol
   Foreign Namespace: join_regress.tt2
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "tt2", "let" : { "ref3" : "$joincol" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref3", "$joincol" ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$tt2_id", "ref5" : "$joincol" } } ], "as" : "tt2" } }, { "$unwind" : { "path" : "$tt2", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$tt1_id", "ref2" : "$joincol", "tt2" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 132:
select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;
 _id | tt1_id | joincol | _id | tt2_id | joincol 
-----+--------+---------+-----+--------+---------
   1 |      1 |      11 |   1 |     21 |      11
   1 |      1 |      11 |   2 |     21 |      11
   2 |      2 |         |     |        |        
(3 rows)

--Testcase 133:
reset enable_hashjoin;
--Testcase 134:
reset enable_nestloop;
--
-- regression test for 8.2 bug with improper re-ordering of left joins
--
--Testcase 135:
CREATE FOREIGN TABLE tt3 (_id int4, f1 int, f2 text)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'tt3');
--Testcase 136:
CREATE FOREIGN TABLE tt4 (_id int4, f1 int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'tt4');
--Testcase 137:
EXPLAIN VERBOSE SELECT a.f1
FROM tt4 a
LEFT JOIN (
        SELECT b.f1
        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)
        WHERE c.f1 IS NULL
) AS d ON (a.f1 = d.f1)
WHERE d.f1 IS NULL;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Hash Anti Join  (cost=37.56..55.75 rows=500 width=4)
   Output: a.f1
   Hash Cond: (a.f1 = b.f1)
   ->  Foreign Scan on public.tt4 a  (cost=0.00..0.00 rows=1000 width=4)
         Output: a._id, a.f1
         Foreign Namespace: join_regress.tt4
         Query document: { "pipeline" : [ { "$project" : { "f1" : { "$numberInt" : "1" } } } ] }
   ->  Hash  (cost=31.31..31.31 rows=500 width=4)
         Output: b.f1
         ->  Hash Anti Join  (cost=12.50..31.31 rows=500 width=4)
               Output: b.f1
               Hash Cond: (b.f1 = c.f1)
               ->  Foreign Scan on public.tt3 b  (cost=0.00..0.00 rows=1000 width=4)
                     Output: b._id, b.f1, b.f2
                     Foreign Namespace: join_regress.tt3
                     Query document: { "pipeline" : [ { "$project" : { "f1" : { "$numberInt" : "1" } } } ] }
               ->  Hash  (cost=0.00..0.00 rows=1000 width=4)
                     Output: c.f1
                     ->  Foreign Scan on public.tt3 c  (cost=0.00..0.00 rows=1000 width=4)
                           Output: c.f1
                           Foreign Namespace: join_regress.tt3
                           Query document: { "pipeline" : [ { "$project" : { "f1" : { "$numberInt" : "1" } } } ] }
(22 rows)

--Testcase 138:
SELECT a.f1
FROM tt4 a
LEFT JOIN (
        SELECT b.f1
        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)
        WHERE c.f1 IS NULL
) AS d ON (a.f1 = d.f1)
WHERE d.f1 IS NULL;
  f1  
------
    0
    1
 9999
(3 rows)

--
-- regression test for problems of the sort depicted in bug #3588
--
--Testcase 139:
CREATE FOREIGN TABLE xx (_id int4, pkxx int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'xx');
--Testcase 140:
CREATE FOREIGN TABLE yy (_id int4, pkyy int, pkxx int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'yy');
--Testcase 141:
select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,
       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx
from yy
     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy
     left join xx xxa on yya.pkxx = xxa.pkxx
     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;
 yy_pkyy | yy_pkxx | yya_pkyy | xxa_pkxx | xxb_pkxx 
---------+---------+----------+----------+----------
     301 |         |          |          |        1
     201 |       1 |          |        1 |        1
     101 |       1 |      101 |        1 |        1
(3 rows)

--
-- regression test for improper pushing of constants across outer-join clauses
-- (as seen in early 8.2.x releases)
--
--Testcase 142:
CREATE FOREIGN TABLE zt1 (_id int4, f1 int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'zt1');
--Testcase 143:
CREATE FOREIGN TABLE zt2 (_id int4, f2 int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'zt2');
--Testcase 144:
CREATE FOREIGN TABLE zt3 (_id int4, f3 int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'zt3');
--Testcase 145:
EXPLAIN VERBOSE select * from
  zt2 left join zt3 on (f2 = f3)
      left join zt1 on (f3 = f1)
where f2 = 53;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
   Output: zt2._id, zt2.f2, zt3._id, zt3.f3, zt1._id, zt1.f1
   Foreign Namespace: join_regress.zt2
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "zt3", "let" : { "ref2" : "$f2" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$eq" : [ "$$ref2", "$f3" ] }, { "$eq" : [ "$f3", { "$numberInt" : "53" } ] } ] } } }, { "$project" : { "ref2" : "$_id", "ref3" : "$f3" } } ], "as" : "zt3" } }, { "$unwind" : { "path" : "$zt3", "preserveNullAndEmptyArrays" : true } }, { "$lookup" : { "from" : "zt1", "let" : { "ref2" : "$f3" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$eq" : [ "$$ref2", "$f1" ] }, { "$eq" : [ "$f1", { "$numberInt" : "53" } ] } ] } } }, { "$project" : { "ref4" : "$_id", "ref5" : "$f1" } } ], "as" : "zt1" } }, { "$unwind" : { "path" : "$zt1", "preserveNullAndEmptyArrays" : true } }, { "$match" : { "f2" : { "$eq" : { "$numberInt" : "53" } } } }, { "$project" : { "ref0" : "$_id", "ref1" : "$f2", "zt3" : { "$numberInt" : "1" }, "zt1" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 146:
select * from
  zt2 left join zt3 on (f2 = f3)
      left join zt1 on (f3 = f1)
where f2 = 53;
 _id | f2 | _id | f3 | _id | f1 
-----+----+-----+----+-----+----
   1 | 53 |     |    |     |   
(1 row)

--Testcase 147:
create temp view zv1 as select *,'dummy'::text AS junk from zt1;
--Testcase 148:
EXPLAIN VERBOSE select * from
  zt2 left join zt3 on (f2 = f3)
      left join zv1 on (f3 = f1)
where f2 = 53;
                                                                                                                                                                                                                                                                              QUERY PLAN                                                                                                                                                                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join  (cost=0.00..3.76 rows=1 width=56)
   Output: zt2._id, zt2.f2, zt3._id, zt3.f3, zt1._id, zt1.f1, ('dummy'::text)
   Hash Cond: (zt1.f1 = zt3.f3)
   ->  Foreign Scan on public.zt1  (cost=0.00..0.00 rows=1000 width=40)
         Output: zt1._id, zt1.f1, 'dummy'::text
         Foreign Namespace: join_regress.zt1
         Query document: { "pipeline" : [ { "$match" : { "f1" : { "$eq" : { "$numberInt" : "53" } } } }, { "$project" : { "_id" : { "$numberInt" : "1" }, "f1" : { "$numberInt" : "1" } } } ] }
   ->  Hash  (cost=0.00..0.00 rows=0 width=0)
         Output: zt2._id, zt2.f2, zt3._id, zt3.f3
         ->  Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
               Output: zt2._id, zt2.f2, zt3._id, zt3.f3
               Foreign Namespace: join_regress.zt2
               Query document: { "pipeline" : [ { "$lookup" : { "from" : "zt3", "let" : { "ref2" : "$f2" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$eq" : [ "$$ref2", "$f3" ] }, { "$eq" : [ "$f3", { "$numberInt" : "53" } ] } ] } } }, { "$project" : { "ref2" : "$_id", "ref3" : "$f3" } } ], "as" : "zt3" } }, { "$unwind" : { "path" : "$zt3", "preserveNullAndEmptyArrays" : true } }, { "$match" : { "f2" : { "$eq" : { "$numberInt" : "53" } } } }, { "$project" : { "ref0" : "$_id", "ref1" : "$f2", "zt3" : { "$numberInt" : "1" } } } ] }
(13 rows)

--Testcase 149:
select * from
  zt2 left join zt3 on (f2 = f3)
      left join zv1 on (f3 = f1)
where f2 = 53;
 _id | f2 | _id | f3 | _id | f1 | junk 
-----+----+-----+----+-----+----+------
   1 | 53 |     |    |     |    | 
(1 row)

--
-- regression test for improper extraction of OR indexqual conditions
-- (as seen in early 8.3.x releases)
--
--Testcase 150:
EXPLAIN VERBOSE select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred
from tenk1 a left join tenk1 b on a.unique2 = b.tenthous
where a.unique1 = 42 and
      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);
                                                                                                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                                                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=0 width=0)
   Output: a.unique2, a.ten, b.tenthous, b.unique2, b.hundred
   Filter: (((b.unique2 IS NULL) AND (a.ten = 2)) OR (b.hundred = 3))
   Foreign Namespace: join_regress.tenk
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "tenk", "let" : { "ref3" : "$unique2" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref3", "$tenthous" ] } } }, { "$project" : { "ref2" : "$tenthous", "ref3" : "$unique2", "ref4" : "$hundred" } } ], "as" : "tenk" } }, { "$unwind" : { "path" : "$tenk", "preserveNullAndEmptyArrays" : true } }, { "$match" : { "unique1" : { "$eq" : { "$numberInt" : "42" } } } }, { "$project" : { "ref0" : "$unique2", "ref1" : "$ten", "tenk" : { "$numberInt" : "1" } } } ] }
(5 rows)

--Testcase 151:
select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred
from tenk1 a left join tenk1 b on a.unique2 = b.tenthous
where a.unique1 = 42 and
      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);
 unique2 | ten | tenthous | unique2 | hundred 
---------+-----+----------+---------+---------
(0 rows)

--
-- test proper positioning of one-time quals in EXISTS (8.4devel bug)
--
--Testcase 152:
prepare foo(bool) as
  select count(*) from tenk1 a left join tenk1 b
    on (a.unique2 = b.unique1 and exists
        (select 1 from tenk1 c where c.thousand = b.unique2 and $1));
--Testcase 153:
execute foo(true);
 count 
-------
 10000
(1 row)

--Testcase 154:
execute foo(false);
 count 
-------
 10000
(1 row)

--
-- test NULL behavior of whole-row Vars, per bug #5025
--
--Testcase 155:
EXPLAIN VERBOSE select t1.q2, count(t2.*)
from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
                                                                                 QUERY PLAN                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=99.66..206.66 rows=200 width=16)
   Output: t1.q2, count(t2.*)
   Group Key: t1.q2
   ->  Merge Left Join  (cost=99.66..179.66 rows=5000 width=52)
         Output: t1.q2, t2.*
         Merge Cond: (t1.q2 = t2.q1)
         ->  Sort  (cost=49.83..52.33 rows=1000 width=8)
               Output: t1.q2
               Sort Key: t1.q2
               ->  Foreign Scan on public.int8_tbl t1  (cost=0.00..0.00 rows=1000 width=8)
                     Output: t1.q2
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$project" : { "q2" : { "$numberInt" : "1" } } } ] }
         ->  Sort  (cost=49.83..52.33 rows=1000 width=52)
               Output: t2.*, t2.q1
               Sort Key: t2.q1
               ->  Foreign Scan on public.int8_tbl t2  (cost=0.00..0.00 rows=1000 width=52)
                     Output: t2.*, t2.q1
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
(20 rows)

--Testcase 156:
select t1.q2, count(t2.*)
from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

--Testcase 157:
EXPLAIN VERBOSE select t1.q2, count(t2.*)
from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
                                                                                 QUERY PLAN                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=99.66..206.66 rows=200 width=16)
   Output: t1.q2, count((ROW(int8_tbl._id, int8_tbl.q1, int8_tbl.q2)))
   Group Key: t1.q2
   ->  Merge Left Join  (cost=99.66..179.66 rows=5000 width=40)
         Output: t1.q2, (ROW(int8_tbl._id, int8_tbl.q1, int8_tbl.q2))
         Merge Cond: (t1.q2 = int8_tbl.q1)
         ->  Sort  (cost=49.83..52.33 rows=1000 width=8)
               Output: t1.q2
               Sort Key: t1.q2
               ->  Foreign Scan on public.int8_tbl t1  (cost=0.00..0.00 rows=1000 width=8)
                     Output: t1.q2
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$project" : { "q2" : { "$numberInt" : "1" } } } ] }
         ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
               Output: int8_tbl.q1, (ROW(int8_tbl._id, int8_tbl.q1, int8_tbl.q2))
               Sort Key: int8_tbl.q1
               ->  Foreign Scan on public.int8_tbl  (cost=0.00..0.00 rows=1000 width=40)
                     Output: int8_tbl.q1, ROW(int8_tbl._id, int8_tbl.q1, int8_tbl.q2)
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
(20 rows)

--Testcase 158:
select t1.q2, count(t2.*)
from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

--Testcase 159:
EXPLAIN VERBOSE select t1.q2, count(t2.*)
from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
                                                                                    QUERY PLAN                                                                                    
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=109.66..216.66 rows=200 width=16)
   Output: t1.q2, count(t2.*)
   Group Key: t1.q2
   ->  Merge Left Join  (cost=109.66..189.66 rows=5000 width=52)
         Output: t1.q2, t2.*
         Merge Cond: (t1.q2 = t2.q1)
         ->  Sort  (cost=49.83..52.33 rows=1000 width=8)
               Output: t1.q2
               Sort Key: t1.q2
               ->  Foreign Scan on public.int8_tbl t1  (cost=0.00..0.00 rows=1000 width=8)
                     Output: t1.q2
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$project" : { "q2" : { "$numberInt" : "1" } } } ] }
         ->  Sort  (cost=59.83..62.33 rows=1000 width=52)
               Output: t2.*, t2.q1
               Sort Key: t2.q1
               ->  Subquery Scan on t2  (cost=0.00..10.00 rows=1000 width=52)
                     Output: t2.*, t2.q1
                     ->  Foreign Scan on public.int8_tbl  (cost=0.00..0.00 rows=1000 width=20)
                           Output: int8_tbl._id, int8_tbl.q1, int8_tbl.q2
                           Foreign Namespace: join_regress.int8_tbl
                           Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
(22 rows)

--Testcase 160:
select t1.q2, count(t2.*)
from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

--Testcase 161:
EXPLAIN VERBOSE select t1.q2, count(t2.*)
from int8_tbl t1 left join
  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2
  on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 GroupAggregate  (cost=99.66..206.66 rows=200 width=16)
   Output: t1.q2, count((ROW(int8_tbl.q1, CASE WHEN (int8_tbl.q2 = 1) THEN '1'::bigint ELSE int8_tbl.q2 END)))
   Group Key: t1.q2
   ->  Merge Left Join  (cost=99.66..179.66 rows=5000 width=40)
         Output: t1.q2, (ROW(int8_tbl.q1, CASE WHEN (int8_tbl.q2 = 1) THEN '1'::bigint ELSE int8_tbl.q2 END))
         Merge Cond: (t1.q2 = int8_tbl.q1)
         ->  Sort  (cost=49.83..52.33 rows=1000 width=8)
               Output: t1.q2
               Sort Key: t1.q2
               ->  Foreign Scan on public.int8_tbl t1  (cost=0.00..0.00 rows=1000 width=8)
                     Output: t1.q2
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$project" : { "q2" : { "$numberInt" : "1" } } } ] }
         ->  Sort  (cost=49.83..52.33 rows=1000 width=40)
               Output: int8_tbl.q1, (ROW(int8_tbl.q1, CASE WHEN (int8_tbl.q2 = 1) THEN '1'::bigint ELSE int8_tbl.q2 END))
               Sort Key: int8_tbl.q1
               ->  Foreign Scan on public.int8_tbl  (cost=0.00..0.00 rows=1000 width=40)
                     Output: int8_tbl.q1, ROW(int8_tbl.q1, CASE WHEN (int8_tbl.q2 = 1) THEN '1'::bigint ELSE int8_tbl.q2 END)
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$project" : { "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
(20 rows)

--Testcase 162:
select t1.q2, count(t2.*)
from int8_tbl t1 left join
  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2
  on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
        q2         | count 
-------------------+-------
 -4567890123456789 |     0
               123 |     2
               456 |     0
  4567890123456789 |     6
(4 rows)

--
-- test incorrect failure to NULL pulled-up subexpressions
--
begin;
--Testcase 163:
CREATE FOREIGN TABLE a (_id int4, code char)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'a');
--Testcase 164:
CREATE FOREIGN TABLE b (_id int4, a char, num integer)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'b');
--Testcase 165:
CREATE FOREIGN TABLE c (_id int4, name char, a char)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'c');
--Testcase 166:
EXPLAIN VERBOSE select c.name, ss.code, ss.b_cnt, ss.const
from c left join
  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const
   from a left join
     (select count(1) as cnt, b.a from b group by b.a) as b_grp
     on a.code = b_grp.a
  ) as ss
  on (c.a = ss.code)
order by c.name;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=501.03..513.53 rows=5000 width=28)
   Output: c.name, a.code, (COALESCE(b_grp.cnt, '0'::bigint)), ('-1'::integer)
   Sort Key: c.name
   ->  Merge Left Join  (cost=113.84..193.84 rows=5000 width=28)
         Output: c.name, a.code, (COALESCE(b_grp.cnt, '0'::bigint)), ('-1'::integer)
         Merge Cond: (c.a = a.code)
         ->  Sort  (cost=49.83..52.33 rows=1000 width=16)
               Output: c.name, c.a
               Sort Key: c.a
               ->  Foreign Scan on public.c  (cost=0.00..0.00 rows=1000 width=16)
                     Output: c.name, c.a
                     Foreign Namespace: join_regress.c
                     Query document: { "pipeline" : [ { "$project" : { "name" : { "$numberInt" : "1" }, "a" : { "$numberInt" : "1" } } } ] }
         ->  Sort  (cost=64.01..66.51 rows=1000 width=20)
               Output: a.code, (COALESCE(b_grp.cnt, '0'::bigint)), ('-1'::integer)
               Sort Key: a.code
               ->  Hash Left Join  (cost=11.50..14.18 rows=1000 width=20)
                     Output: a.code, COALESCE(b_grp.cnt, '0'::bigint), '-1'::integer
                     Inner Unique: true
                     Hash Cond: (a.code = b_grp.a)
                     ->  Foreign Scan on public.a  (cost=0.00..0.00 rows=1000 width=8)
                           Output: a._id, a.code
                           Foreign Namespace: join_regress.a
                           Query document: { "pipeline" : [ { "$project" : { "code" : { "$numberInt" : "1" } } } ] }
                     ->  Hash  (cost=9.00..9.00 rows=200 width=16)
                           Output: b_grp.a, b_grp.cnt
                           ->  Subquery Scan on b_grp  (cost=5.00..9.00 rows=200 width=16)
                                 Output: b_grp.a, b_grp.cnt
                                 ->  HashAggregate  (cost=5.00..7.00 rows=200 width=16)
                                       Output: count(1), b.a
                                       Group Key: b.a
                                       ->  Foreign Scan on public.b  (cost=0.00..0.00 rows=1000 width=8)
                                             Output: b._id, b.a, b.num
                                             Foreign Namespace: join_regress.b
                                             Query document: { "pipeline" : [ { "$project" : { "a" : { "$numberInt" : "1" } } } ] }
(35 rows)

--Testcase 167:
select c.name, ss.code, ss.b_cnt, ss.const
from c left join
  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const
   from a left join
     (select count(1) as cnt, b.a from b group by b.a) as b_grp
     on a.code = b_grp.a
  ) as ss
  on (c.a = ss.code)
order by c.name;
 name | code | b_cnt | const 
------+------+-------+-------
 A    | p    |     2 |    -1
 B    | q    |     0 |    -1
 C    |      |       |      
(3 rows)

rollback;
--
-- test incorrect handling of placeholders that only appear in targetlists,
-- per bug #6154
--
--Testcase 168:
SELECT * FROM
( SELECT 1 as key1 ) sub1
LEFT JOIN
( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM
    ( SELECT 1 as key3 ) sub3
    LEFT JOIN
    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
        ( SELECT 1 as key5 ) sub5
        LEFT JOIN
        ( SELECT 2 as key6, 42 as value1 ) sub6
        ON sub5.key5 = sub6.key6
    ) sub4
    ON sub4.key5 = sub3.key3
) sub2
ON sub1.key1 = sub2.key3;
 key1 | key3 | value2 | value3 
------+------+--------+--------
    1 |    1 |      1 |      1
(1 row)

-- test the path using join aliases, too
--Testcase 169:
SELECT * FROM
( SELECT 1 as key1 ) sub1
LEFT JOIN
( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM
    ( SELECT 1 as key3 ) sub3
    LEFT JOIN
    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
        ( SELECT 1 as key5 ) sub5
        LEFT JOIN
        ( SELECT 2 as key6, 42 as value1 ) sub6
        ON sub5.key5 = sub6.key6
    ) sub4
    ON sub4.key5 = sub3.key3
) sub2
ON sub1.key1 = sub2.key3;
 key1 | key3 | value2 | value3 
------+------+--------+--------
    1 |    1 |      1 |      1
(1 row)

--
-- nested nestloops can require nested PlaceHolderVars
--
--Testcase 170:
CREATE FOREIGN TABLE nt1 (_id int4, id int, a1 boolean, a2 boolean)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'nt1');
--Testcase 171:
CREATE FOREIGN TABLE nt2 (_id int4, id int, nt1_id int, b1 boolean, b2 boolean)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'nt2');
--Testcase 172:
CREATE FOREIGN TABLE nt3 (_id int4, id int, nt2_id int, c1 boolean)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'nt3');
--Testcase 173:
explain (costs off)
select nt3.id
from nt3 as nt3
  left join
    (select nt2.*, (nt2.b1 and ss1.a3) AS b3
     from nt2 as nt2
       left join
         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
         on ss1.id = nt2.nt1_id
    ) as ss2
    on ss2.id = nt3.nt2_id
where nt3.id = 1 and ss2.b3;
                           QUERY PLAN                           
----------------------------------------------------------------
 Merge Join
   Merge Cond: (nt3.nt2_id = nt2.id)
   ->  Sort
         Sort Key: nt3.nt2_id
         ->  Foreign Scan on nt3
               Foreign Namespace: join_regress.nt3
   ->  Sort
         Sort Key: nt2.id
         ->  Merge Join
               Merge Cond: (nt2.nt1_id = nt1.id)
               Join Filter: (nt2.b1 AND ((nt1.id IS NOT NULL)))
               ->  Sort
                     Sort Key: nt2.nt1_id
                     ->  Foreign Scan on nt2
                           Foreign Namespace: join_regress.nt2
               ->  Sort
                     Sort Key: nt1.id
                     ->  Foreign Scan on nt1
                           Foreign Namespace: join_regress.nt1
(19 rows)

--Testcase 174:
select nt3.id
from nt3 as nt3
  left join
    (select nt2.*, (nt2.b1 and ss1.a3) AS b3
     from nt2 as nt2
       left join
         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
         on ss1.id = nt2.nt1_id
    ) as ss2
    on ss2.id = nt3.nt2_id
where nt3.id = 1 and ss2.b3;
 id 
----
  1
(1 row)

--
-- test case where a PlaceHolderVar is propagated into a subquery
--
--Testcase 175:
explain (costs off)
select * from
  int8_tbl t1 left join
  (select q1 as x, 42 as y from int8_tbl t2) ss
  on t1.q2 = ss.x
where
  1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
order by 1,2;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Sort
   Sort Key: t1._id, t1.q1
   ->  Merge Left Join
         Merge Cond: (t1.q2 = t2.q1)
         Filter: (1 = (SubPlan 1))
         ->  Sort
               Sort Key: t1.q2
               ->  Foreign Scan on int8_tbl t1
                     Foreign Namespace: join_regress.int8_tbl
         ->  Sort
               Sort Key: t2.q1
               ->  Foreign Scan on int8_tbl t2
                     Foreign Namespace: join_regress.int8_tbl
         SubPlan 1
           ->  Limit
                 ->  Result
                       One-Time Filter: ((42) IS NOT NULL)
                       ->  Foreign Scan on int8_tbl t3
                             Foreign Namespace: join_regress.int8_tbl
(19 rows)

--Testcase 176:
select * from
  int8_tbl t1 left join
  (select q1 as x, 42 as y from int8_tbl t2) ss
  on t1.q2 = ss.x
where
  1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
order by 1,2;
 _id |        q1        |        q2        |        x         | y  
-----+------------------+------------------+------------------+----
   2 |              123 | 4567890123456789 | 4567890123456789 | 42
   2 |              123 | 4567890123456789 | 4567890123456789 | 42
   2 |              123 | 4567890123456789 | 4567890123456789 | 42
   3 | 4567890123456789 |              123 |              123 | 42
   3 | 4567890123456789 |              123 |              123 | 42
   4 | 4567890123456789 | 4567890123456789 | 4567890123456789 | 42
   4 | 4567890123456789 | 4567890123456789 | 4567890123456789 | 42
   4 | 4567890123456789 | 4567890123456789 | 4567890123456789 | 42
(8 rows)

--
-- variant where a PlaceHolderVar is needed at a join, but not above the join
--
explain (costs off)
select * from
  int4_tbl as i41,
  lateral
    (select 1 as x from
      (select i41.f1 as lat,
              i42.f1 as loc from
         int8_tbl as i81, int4_tbl as i42) as ss1
      right join int4_tbl as i43 on (i43.f1 > 1)
      where ss1.loc = ss1.lat) as ss2
where i41.f1 > 0;
                          QUERY PLAN                          
--------------------------------------------------------------
 Nested Loop
   ->  Nested Loop
         ->  Foreign Scan on int4_tbl i41
               Foreign Namespace: join_regress.int4_tbl
         ->  Nested Loop
               Join Filter: (i41.f1 = i42.f1)
               ->  Foreign Scan on int8_tbl i81
                     Foreign Namespace: join_regress.int8_tbl
               ->  Foreign Scan on int4_tbl i42
                     Foreign Namespace: join_regress.int4_tbl
   ->  Foreign Scan on int4_tbl i43
         Foreign Namespace: join_regress.int4_tbl
(12 rows)

select * from
  int4_tbl as i41,
  lateral
    (select 1 as x from
      (select i41.f1 as lat,
              i42.f1 as loc from
         int8_tbl as i81, int4_tbl as i42) as ss1
      right join int4_tbl as i43 on (i43.f1 > 1)
      where ss1.loc = ss1.lat) as ss2
where i41.f1 > 0;
 _id |     f1     | x 
-----+------------+---
   2 |     123456 | 1
   2 |     123456 | 1
   2 |     123456 | 1
   2 |     123456 | 1
   2 |     123456 | 1
   2 |     123456 | 1
   2 |     123456 | 1
   2 |     123456 | 1
   2 |     123456 | 1
   2 |     123456 | 1
   4 | 2147483647 | 1
   4 | 2147483647 | 1
   4 | 2147483647 | 1
   4 | 2147483647 | 1
   4 | 2147483647 | 1
   4 | 2147483647 | 1
   4 | 2147483647 | 1
   4 | 2147483647 | 1
   4 | 2147483647 | 1
   4 | 2147483647 | 1
(20 rows)

--
-- test for ability to use a cartesian join when necessary
--
--Testcase 177:
CREATE FOREIGN TABLE q1 (_id int4, q1 int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'q1');
--Testcase 178:
CREATE FOREIGN TABLE q2 (_id int4, q2 int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'q2');
analyze q1;
analyze q2;
--
-- test a corner case in which we shouldn't apply the star-schema optimization
--
--Testcase 179:
explain (costs off)
select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (select 1,0 from onerow) v1(x1,x2)
               left join (select 3,1 from onerow) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Nested Loop
   ->  Hash Join
         Hash Cond: (t1.unique2 = (11))
         Join Filter: (t1.stringu1 > t2.stringu2)
         ->  Foreign Scan on tenk1 t1
               Foreign Namespace: join_regress.tenk
         ->  Hash
               ->  Nested Loop
                     ->  Seq Scan on onerow
                     ->  Hash Join
                           Hash Cond: (t2.unique1 = (3))
                           ->  Foreign Scan on tenk1 t2
                                 Foreign Namespace: join_regress.tenk
                           ->  Hash
                                 ->  Seq Scan on onerow onerow_1
   ->  Foreign Scan on int4_tbl i1
         Foreign Namespace: join_regress.int4_tbl
(17 rows)

--Testcase 180:
select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (select 1,0 from onerow) v1(x1,x2)
               left join (select 3,1 from onerow) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
 unique2 | stringu1 | unique1 | stringu2 
---------+----------+---------+----------
      11 | WFAAAA   |       3 | LKIAAA
(1 row)

-- this variant is foldable by the remove-useless-RESULT-RTEs code
--Testcase 181:
explain (costs off)
select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (values(1,0)) v1(x1,x2)
               left join (values(3,1)) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Merge Join
   Merge Cond: (t2.unique1 = (3))
   Join Filter: (t1.stringu1 > t2.stringu2)
   ->  Sort
         Sort Key: t2.unique1
         ->  Foreign Scan on tenk1 t2
               Foreign Namespace: join_regress.tenk
   ->  Sort
         Sort Key: (3)
         ->  Merge Join
               Merge Cond: (t1.unique2 = (11))
               ->  Sort
                     Sort Key: t1.unique2
                     ->  Foreign Scan on tenk1 t1
                           Foreign Namespace: join_regress.tenk
               ->  Sort
                     Sort Key: (11)
                     ->  Foreign Scan on int4_tbl i1
                           Foreign Namespace: join_regress.int4_tbl
(19 rows)

--Testcase 182:
select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (values(1,0)) v1(x1,x2)
               left join (values(3,1)) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
 unique2 | stringu1 | unique1 | stringu2 
---------+----------+---------+----------
      11 | WFAAAA   |       3 | LKIAAA
(1 row)

-- Here's a variant that we can't fold too aggressively, though,
-- or we end up with noplace to evaluate the lateral PHV
--Testcase 183:
explain (verbose, costs off)
select * from
  (select 1 as x) ss1 left join (select 2 as y) ss2 on (true),
  lateral (select ss2.y as z limit 1) ss3;
        QUERY PLAN         
---------------------------
 Nested Loop
   Output: 1, (2), ((2))
   ->  Result
         Output: 2
   ->  Limit
         Output: ((2))
         ->  Result
               Output: (2)
(8 rows)

--Testcase 184:
select * from
  (select 1 as x) ss1 left join (select 2 as y) ss2 on (true),
  lateral (select ss2.y as z limit 1) ss3;
 x | y | z 
---+---+---
 1 | 2 | 2
(1 row)

--
-- test inlining of immutable functions
--
--Testcase 185:
create function f_immutable_int4(i integer) returns integer as
$$ begin return i; end; $$ language plpgsql immutable;
-- test inlining of immutable functions with PlaceHolderVars
--Testcase 186:
explain (costs off)
select nt3.id
from nt3 as nt3
  left join
    (select nt2.*, (nt2.b1 or i4 = 42) AS b3
     from nt2 as nt2
       left join
         f_immutable_int4(0) i4
         on i4 = nt2.nt1_id
    ) as ss2
    on ss2.id = nt3.nt2_id
where nt3.id = 1 and ss2.b3;
                       QUERY PLAN                        
---------------------------------------------------------
 Merge Left Join
   Merge Cond: (nt3.nt2_id = nt2.id)
   Filter: ((nt2.b1 OR ((0) = 42)))
   ->  Sort
         Sort Key: nt3.nt2_id
         ->  Foreign Scan on nt3
               Foreign Namespace: join_regress.nt3
   ->  Sort
         Sort Key: nt2.id
         ->  Nested Loop Left Join
               Join Filter: (0 = nt2.nt1_id)
               ->  Foreign Scan on nt2
                     Foreign Namespace: join_regress.nt2
               ->  Materialize
                     ->  Result
(15 rows)

--Testcase 187:
drop function f_immutable_int4(int);
--
-- test placement of movable quals in a parameterized join tree
--
--Testcase 188:
explain (costs off)
select * from tenk1 t1 left join
  (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
  on t1.hundred = t2.hundred and t1.ten = t3.ten
where t1.unique1 = 1;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Merge Left Join
   Merge Cond: ((t1.hundred = t2.hundred) AND (t1.ten = t3.ten))
   ->  Sort
         Sort Key: t1.hundred, t1.ten
         ->  Foreign Scan on tenk1 t1
               Foreign Namespace: join_regress.tenk
   ->  Sort
         Sort Key: t2.hundred, t3.ten
         ->  Merge Join
               Merge Cond: (t2.thousand = t3.unique2)
               ->  Sort
                     Sort Key: t2.thousand
                     ->  Foreign Scan on tenk1 t2
                           Foreign Namespace: join_regress.tenk
               ->  Sort
                     Sort Key: t3.unique2
                     ->  Foreign Scan on tenk1 t3
                           Foreign Namespace: join_regress.tenk
(18 rows)

--Testcase 189:
explain (costs off)
select * from tenk1 t1 left join
  (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
  on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten
where t1.unique1 = 1;
                           QUERY PLAN                           
----------------------------------------------------------------
 Merge Left Join
   Merge Cond: (t1.hundred = t2.hundred)
   Join Filter: ((t1.ten + t2.ten) = t3.ten)
   ->  Sort
         Sort Key: t1.hundred
         ->  Foreign Scan on tenk1 t1
               Foreign Namespace: join_regress.tenk
   ->  Sort
         Sort Key: t2.hundred
         ->  Merge Join
               Merge Cond: (t2.thousand = t3.unique2)
               ->  Sort
                     Sort Key: t2.thousand
                     ->  Foreign Scan on tenk1 t2
                           Foreign Namespace: join_regress.tenk
               ->  Sort
                     Sort Key: t3.unique2
                     ->  Foreign Scan on tenk1 t3
                           Foreign Namespace: join_regress.tenk
(19 rows)

--Testcase 190:
explain (costs off)
select count(*) from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
  join int4_tbl on b.thousand = f1;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Aggregate
   ->  Merge Join
         Merge Cond: (int4_tbl.f1 = b.thousand)
         ->  Sort
               Sort Key: int4_tbl.f1
               ->  Foreign Scan on int4_tbl
                     Foreign Namespace: join_regress.int4_tbl
         ->  Sort
               Sort Key: b.thousand
               ->  Merge Left Join
                     Merge Cond: (a.thousand = c.thousand)
                     Join Filter: (a.unique2 = b.unique1)
                     ->  Sort
                           Sort Key: a.thousand
                           ->  Merge Join
                                 Merge Cond: (a.unique1 = b.unique2)
                                 ->  Sort
                                       Sort Key: a.unique1
                                       ->  Foreign Scan on tenk1 a
                                             Foreign Namespace: join_regress.tenk
                                 ->  Sort
                                       Sort Key: b.unique2
                                       ->  Foreign Scan on tenk1 b
                                             Foreign Namespace: join_regress.tenk
                     ->  Sort
                           Sort Key: c.thousand
                           ->  Foreign Scan on tenk1 c
                                 Foreign Namespace: join_regress.tenk
(28 rows)

--Testcase 191:
select count(*) from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
  join int4_tbl on b.thousand = f1;
 count 
-------
    10
(1 row)

--Testcase 192:
explain (costs off)
select b.unique1 from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
  join int4_tbl i1 on b.thousand = f1
  right join int4_tbl i2 on i2.f1 = b.tenthous
  order by 1;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Sort
   Sort Key: b.unique1
   ->  Merge Left Join
         Merge Cond: (i2.f1 = b.tenthous)
         ->  Sort
               Sort Key: i2.f1
               ->  Foreign Scan on int4_tbl i2
                     Foreign Namespace: join_regress.int4_tbl
         ->  Sort
               Sort Key: b.tenthous
               ->  Merge Join
                     Merge Cond: (i1.f1 = b.thousand)
                     ->  Sort
                           Sort Key: i1.f1
                           ->  Foreign Scan on int4_tbl i1
                                 Foreign Namespace: join_regress.int4_tbl
                     ->  Sort
                           Sort Key: b.thousand
                           ->  Merge Left Join
                                 Merge Cond: (a.thousand = c.thousand)
                                 Join Filter: (b.unique1 = 42)
                                 ->  Sort
                                       Sort Key: a.thousand
                                       ->  Merge Join
                                             Merge Cond: (a.unique1 = b.unique2)
                                             ->  Sort
                                                   Sort Key: a.unique1
                                                   ->  Foreign Scan on tenk1 a
                                                         Foreign Namespace: join_regress.tenk
                                             ->  Sort
                                                   Sort Key: b.unique2
                                                   ->  Foreign Scan on tenk1 b
                                                         Foreign Namespace: join_regress.tenk
                                 ->  Sort
                                       Sort Key: c.thousand
                                       ->  Foreign Scan on tenk1 c
                                             Foreign Namespace: join_regress.tenk
(37 rows)

--Testcase 193:
select b.unique1 from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
  join int4_tbl i1 on b.thousand = f1
  right join int4_tbl i2 on i2.f1 = b.tenthous
  order by 1;
 unique1 
---------
       0
        
        
        
        
(5 rows)

--Testcase 194:
explain (costs off)
select * from
(
  select unique1, q1, coalesce(unique1, -1) + q1 as fault
  from int8_tbl left join tenk1 on (q2 = unique2)
) ss
where fault = 122
order by fault;
                        QUERY PLAN                         
-----------------------------------------------------------
 Foreign Scan
   Filter: ((COALESCE(unique1, '-1'::integer) + q1) = 122)
   Foreign Namespace: join_regress.int8_tbl
(3 rows)

--Testcase 195:
select * from
(
  select unique1, q1, coalesce(unique1, -1) + q1 as fault
  from int8_tbl left join tenk1 on (q2 = unique2)
) ss
where fault = 122
order by fault;
 unique1 | q1  | fault 
---------+-----+-------
         | 123 |   122
(1 row)

--Testcase 196:
explain (costs off)
select * from
(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x
left join unnest(v1ys) as u1(u1y) on u1y = v2y;
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop Left Join
   ->  Values Scan on "*VALUES*"
   ->  Hash Right Join
         Hash Cond: (u1.u1y = "*VALUES*_1".column2)
         Filter: ("*VALUES*_1".column1 = "*VALUES*".column1)
         ->  Function Scan on unnest u1
         ->  Hash
               ->  Values Scan on "*VALUES*_1"
(8 rows)

--Testcase 197:
select * from
(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x
left join unnest(v1ys) as u1(u1y) on u1y = v2y;
 v1x |  v1ys   | v2x | v2y | u1y 
-----+---------+-----+-----+-----
   1 | {10,20} |   1 |  10 |  10
   2 | {20,30} |   2 |  20 |  20
(2 rows)

--
-- test handling of potential equivalence clauses above outer joins
--
--Testcase 198:
explain (costs off)
select q1, unique2, thousand, hundred
  from int8_tbl a left join tenk1 b on q1 = unique2
  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Foreign Scan
   Filter: ((COALESCE(thousand, 123) = q1) AND (q1 = COALESCE(hundred, 123)))
   Foreign Namespace: join_regress.int8_tbl
(3 rows)

--Testcase 199:
select q1, unique2, thousand, hundred
  from int8_tbl a left join tenk1 b on q1 = unique2
  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
 q1 | unique2 | thousand | hundred 
----+---------+----------+---------
(0 rows)

--Testcase 200:
explain (costs off)
select f1, unique2, case when unique2 is null then f1 else 0 end
  from int4_tbl a left join tenk1 b on f1 = unique2
  where (case when unique2 is null then f1 else 0 end) = 0;
                           QUERY PLAN                           
----------------------------------------------------------------
 Foreign Scan
   Filter: (CASE WHEN (unique2 IS NULL) THEN f1 ELSE 0 END = 0)
   Foreign Namespace: join_regress.int4_tbl
(3 rows)

--Testcase 201:
select f1, unique2, case when unique2 is null then f1 else 0 end
  from int4_tbl a left join tenk1 b on f1 = unique2
  where (case when unique2 is null then f1 else 0 end) = 0;
 f1 | unique2 | case 
----+---------+------
  0 |       0 |    0
(1 row)

--
-- another case with equivalence clauses above outer joins (bug #8591)
--
--Testcase 202:
explain (costs off)
select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Hash Right Join
   Hash Cond: (c.unique2 = COALESCE(b.twothousand, a.twothousand))
   ->  Foreign Scan on tenk1 c
         Foreign Namespace: join_regress.tenk
   ->  Hash
         ->  Foreign Scan
               Filter: (COALESCE(twothousand, twothousand) = 44)
               Foreign Namespace: join_regress.tenk
(8 rows)

--Testcase 203:
select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;
 unique1 | unique1 | unique1 | coalesce 
---------+---------+---------+----------
(0 rows)

--
-- check handling of join aliases when flattening multiple levels of subquery
--
--Testcase 204:
explain (verbose, costs off)
select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
  (values (0),(1)) foo1(join_key)
left join
  (select join_key, bug_field from
    (select ss1.join_key, ss1.bug_field from
      (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
    ) foo2
   left join
    (select unique2 as join_key from tenk1 i2) ss2
   using (join_key)
  ) foo3
using (join_key);
                                                                                                                                                                               QUERY PLAN                                                                                                                                                                               
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Left Join
   Output: "*VALUES*".column1, i1.f1, (666)
   Hash Cond: ("*VALUES*".column1 = i1.f1)
   ->  Values Scan on "*VALUES*"
         Output: "*VALUES*".column1
   ->  Hash
         Output: i1.f1, (666)
         ->  Foreign Scan
               Output: i1.f1, 666
               Foreign Namespace: join_regress.int4_tbl
               Query document: { "pipeline" : [ { "$lookup" : { "from" : "tenk", "let" : { "ref2" : "$f1" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref2", "$unique2" ] } } } ], "as" : "tenk" } }, { "$unwind" : { "path" : "$tenk", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$f1", "tenk" : { "$numberInt" : "1" } } } ] }
(11 rows)

--Testcase 205:
select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
  (values (0),(1)) foo1(join_key)
left join
  (select join_key, bug_field from
    (select ss1.join_key, ss1.bug_field from
      (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
    ) foo2
   left join
    (select unique2 as join_key from tenk1 i2) ss2
   using (join_key)
  ) foo3
using (join_key);
 foo1_id | foo3_id | bug_field 
---------+---------+-----------
       0 |       0 |       666
       1 |         |          
(2 rows)

--
-- test successful handling of nested outer joins with degenerate join quals
--
--Testcase 206:
CREATE FOREIGN TABLE text_tbl (_id int4, f1 text)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'text_tbl');
--Testcase 207:
explain (verbose, costs off)
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Left Join
   Output: t1._id, t1.f1
   Hash Cond: (i8.q2 = i4.f1)
   ->  Nested Loop Left Join
         Output: t1._id, t1.f1, i8.q2
         Join Filter: (t1.f1 = '***'::text)
         ->  Foreign Scan on public.text_tbl t1
               Output: t1._id, t1.f1
               Foreign Namespace: join_regress.text_tbl
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "f1" : { "$numberInt" : "1" } } } ] }
         ->  Materialize
               Output: i8.q2
               ->  Merge Left Join
                     Output: i8.q2
                     Merge Cond: (i8b1.q2 = (NULL::integer))
                     ->  Sort
                           Output: i8b1.q2
                           Sort Key: i8b1.q2
                           ->  Foreign Scan on public.int8_tbl i8b1
                                 Output: i8b1.q2
                                 Foreign Namespace: join_regress.int8_tbl
                                 Query document: { "pipeline" : [ { "$project" : { "q2" : { "$numberInt" : "1" } } } ] }
                     ->  Sort
                           Output: i8.q2, (NULL::integer)
                           Sort Key: (NULL::integer)
                           ->  Merge Join
                                 Output: i8.q2, (NULL::integer)
                                 Merge Cond: (i8.q1 = i8b2.q1)
                                 ->  Sort
                                       Output: i8.q1, i8.q2
                                       Sort Key: i8.q1
                                       ->  Foreign Scan on public.int8_tbl i8
                                             Output: i8.q1, i8.q2
                                             Foreign Namespace: join_regress.int8_tbl
                                             Query document: { "pipeline" : [ { "$project" : { "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
                                 ->  Sort
                                       Output: i8b2.q1, (NULL::integer)
                                       Sort Key: i8b2.q1
                                       ->  Foreign Scan on public.int8_tbl i8b2
                                             Output: i8b2.q1, NULL::integer
                                             Foreign Namespace: join_regress.int8_tbl
                                             Query document: { "pipeline" : [ { "$project" : { "q1" : { "$numberInt" : "1" } } } ] }
   ->  Hash
         Output: i4.f1
         ->  Foreign Scan on public.int4_tbl i4
               Output: i4.f1
               Foreign Namespace: join_regress.int4_tbl
               Query document: { "pipeline" : [ { "$project" : { "f1" : { "$numberInt" : "1" } } } ] }
(48 rows)

--Testcase 208:
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
 _id |        f1         
-----+-------------------
   1 | doh!
   2 | hi de ho neighbor
(2 rows)

--Testcase 209:
explain (verbose, costs off)
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Left Join
   Output: t1._id, t1.f1
   Hash Cond: (i8.q2 = i4.f1)
   ->  Nested Loop Left Join
         Output: t1._id, t1.f1, i8.q2
         Join Filter: (t1.f1 = '***'::text)
         ->  Foreign Scan on public.text_tbl t1
               Output: t1._id, t1.f1
               Foreign Namespace: join_regress.text_tbl
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "f1" : { "$numberInt" : "1" } } } ] }
         ->  Materialize
               Output: i8.q2
               ->  Hash Right Join
                     Output: i8.q2
                     Hash Cond: ((NULL::integer) = i8b1.q2)
                     ->  Hash Right Join
                           Output: i8.q2, (NULL::integer)
                           Hash Cond: (i8b2.q1 = i8.q1)
                           ->  Nested Loop
                                 Output: i8b2.q1, NULL::integer
                                 ->  Foreign Scan on public.int8_tbl i8b2
                                       Output: i8b2._id, i8b2.q1, i8b2.q2
                                       Foreign Namespace: join_regress.int8_tbl
                                       Query document: { "pipeline" : [ { "$project" : { "q1" : { "$numberInt" : "1" } } } ] }
                                 ->  Foreign Scan on public.int4_tbl i4b2
                                       Output: i4b2._id, i4b2.f1
                                       Foreign Namespace: join_regress.int4_tbl
                                       Query document: { "pipeline" : [  ] }
                           ->  Hash
                                 Output: i8.q1, i8.q2
                                 ->  Foreign Scan on public.int8_tbl i8
                                       Output: i8.q1, i8.q2
                                       Foreign Namespace: join_regress.int8_tbl
                                       Query document: { "pipeline" : [ { "$project" : { "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
                     ->  Hash
                           Output: i8b1.q2
                           ->  Foreign Scan on public.int8_tbl i8b1
                                 Output: i8b1.q2
                                 Foreign Namespace: join_regress.int8_tbl
                                 Query document: { "pipeline" : [ { "$project" : { "q2" : { "$numberInt" : "1" } } } ] }
   ->  Hash
         Output: i4.f1
         ->  Foreign Scan on public.int4_tbl i4
               Output: i4.f1
               Foreign Namespace: join_regress.int4_tbl
               Query document: { "pipeline" : [ { "$project" : { "f1" : { "$numberInt" : "1" } } } ] }
(46 rows)

--Testcase 210:
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
 _id |        f1         
-----+-------------------
   1 | doh!
   2 | hi de ho neighbor
(2 rows)

--Testcase 211:
explain (verbose, costs off)
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2
                 where q1 = f1) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Left Join
   Output: t1._id, t1.f1
   Hash Cond: (i8.q2 = i4.f1)
   ->  Nested Loop Left Join
         Output: t1._id, t1.f1, i8.q2
         Join Filter: (t1.f1 = '***'::text)
         ->  Foreign Scan on public.text_tbl t1
               Output: t1._id, t1.f1
               Foreign Namespace: join_regress.text_tbl
               Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "f1" : { "$numberInt" : "1" } } } ] }
         ->  Materialize
               Output: i8.q2
               ->  Merge Left Join
                     Output: i8.q2
                     Merge Cond: (i8b1.q2 = (NULL::integer))
                     ->  Sort
                           Output: i8b1.q2
                           Sort Key: i8b1.q2
                           ->  Foreign Scan on public.int8_tbl i8b1
                                 Output: i8b1.q2
                                 Foreign Namespace: join_regress.int8_tbl
                                 Query document: { "pipeline" : [ { "$project" : { "q2" : { "$numberInt" : "1" } } } ] }
                     ->  Sort
                           Output: i8.q2, (NULL::integer)
                           Sort Key: (NULL::integer)
                           ->  Merge Left Join
                                 Output: i8.q2, (NULL::integer)
                                 Merge Cond: (i8.q1 = i8b2.q1)
                                 ->  Sort
                                       Output: i8.q1, i8.q2
                                       Sort Key: i8.q1
                                       ->  Foreign Scan on public.int8_tbl i8
                                             Output: i8.q1, i8.q2
                                             Foreign Namespace: join_regress.int8_tbl
                                             Query document: { "pipeline" : [ { "$project" : { "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
                                 ->  Materialize
                                       Output: i8b2.q1, (NULL::integer)
                                       ->  Merge Join
                                             Output: i8b2.q1, NULL::integer
                                             Merge Cond: (i8b2.q1 = i4b2.f1)
                                             ->  Sort
                                                   Output: i8b2.q1
                                                   Sort Key: i8b2.q1
                                                   ->  Foreign Scan on public.int8_tbl i8b2
                                                         Output: i8b2.q1
                                                         Foreign Namespace: join_regress.int8_tbl
                                                         Query document: { "pipeline" : [ { "$project" : { "q1" : { "$numberInt" : "1" } } } ] }
                                             ->  Sort
                                                   Output: i4b2.f1
                                                   Sort Key: i4b2.f1
                                                   ->  Foreign Scan on public.int4_tbl i4b2
                                                         Output: i4b2.f1
                                                         Foreign Namespace: join_regress.int4_tbl
                                                         Query document: { "pipeline" : [ { "$project" : { "f1" : { "$numberInt" : "1" } } } ] }
   ->  Hash
         Output: i4.f1
         ->  Foreign Scan on public.int4_tbl i4
               Output: i4.f1
               Foreign Namespace: join_regress.int4_tbl
               Query document: { "pipeline" : [ { "$project" : { "f1" : { "$numberInt" : "1" } } } ] }
(60 rows)

--Testcase 212:
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2
                 where q1 = f1) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
 _id |        f1         
-----+-------------------
   1 | doh!
   2 | hi de ho neighbor
(2 rows)

--Testcase 213:
explain (verbose, costs off)
select * from
  text_tbl t1
  inner join int8_tbl i8
  on i8.q2 = 456
  right join text_tbl t2
  on t1.f1 = 'doh!'
  left join int4_tbl i4
  on i8.q1 = i4.f1;
                                                                                                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                                                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: t1._id, t1.f1, i8._id, i8.q1, i8.q2, t2._id, t2.f1, i4._id, i4.f1
   ->  Foreign Scan on public.text_tbl t2
         Output: t2._id, t2.f1
         Foreign Namespace: join_regress.text_tbl
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "f1" : { "$numberInt" : "1" } } } ] }
   ->  Materialize
         Output: i8._id, i8.q1, i8.q2, i4._id, i4.f1, t1._id, t1.f1
         ->  Nested Loop
               Output: i8._id, i8.q1, i8.q2, i4._id, i4.f1, t1._id, t1.f1
               ->  Foreign Scan
                     Output: i8._id, i8.q1, i8.q2, i4._id, i4.f1
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$lookup" : { "from" : "int4_tbl", "let" : { "ref2" : "$q1" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref2", "$f1" ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$f1" } } ], "as" : "int4_tbl" } }, { "$unwind" : { "path" : "$int4_tbl", "preserveNullAndEmptyArrays" : true } }, { "$match" : { "q2" : { "$eq" : { "$numberInt" : "456" } } } }, { "$project" : { "ref0" : "$_id", "ref1" : "$q1", "ref2" : "$q2", "int4_tbl" : { "$numberInt" : "1" } } } ] }
               ->  Foreign Scan on public.text_tbl t1
                     Output: t1._id, t1.f1
                     Foreign Namespace: join_regress.text_tbl
                     Query document: { "pipeline" : [ { "$match" : { "f1" : { "$eq" : "doh!" } } }, { "$project" : { "_id" : { "$numberInt" : "1" }, "f1" : { "$numberInt" : "1" } } } ] }
(18 rows)

--Testcase 214:
select * from
  text_tbl t1
  inner join int8_tbl i8
  on i8.q2 = 456
  right join text_tbl t2
  on t1.f1 = 'doh!'
  left join int4_tbl i4
  on i8.q1 = i4.f1;
 _id |  f1  | _id | q1  | q2  | _id |        f1         | _id | f1 
-----+------+-----+-----+-----+-----+-------------------+-----+----
   1 | doh! |   1 | 123 | 456 |   1 | doh!              |     |   
   1 | doh! |   1 | 123 | 456 |   2 | hi de ho neighbor |     |   
(2 rows)

--
-- test for appropriate join order in the presence of lateral references
--
--Testcase 215:
explain (verbose, costs off)
select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss
where t1.f1 = ss.f1;
                                                                                                                                                                                                                              QUERY PLAN                                                                                                                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: t1._id, t1.f1, i8._id, i8.q1, i8.q2, (i8.q1), t2.f1
   Join Filter: (t1.f1 = t2.f1)
   ->  Foreign Scan
         Output: t1._id, t1.f1, i8._id, i8.q1, i8.q2
         Foreign Namespace: join_regress.text_tbl
         Query document: { "pipeline" : [ { "$lookup" : { "from" : "int8_tbl", "let" : {  }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$q2", { "$numberInt" : "123" } ] } } }, { "$project" : { "ref2" : "$_id", "ref3" : "$q1", "ref4" : "$q2" } } ], "as" : "int8_tbl" } }, { "$unwind" : { "path" : "$int8_tbl", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$f1", "int8_tbl" : { "$numberInt" : "1" } } } ] }
   ->  Foreign Scan on public.text_tbl t2
         Output: i8.q1, t2.f1
         Foreign Namespace: join_regress.text_tbl
         Query document: { "pipeline" : [ { "$project" : { "f1" : { "$numberInt" : "1" } } }, { "$limit" : { "$numberLong" : "1"} } ] }
(11 rows)

--Testcase 216:
select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss
where t1.f1 = ss.f1;
 _id |  f1  | _id |        q1        | q2  |        q1        |  f1  
-----+------+-----+------------------+-----+------------------+------
   1 | doh! |   3 | 4567890123456789 | 123 | 4567890123456789 | doh!
(1 row)

--Testcase 217:
explain (verbose, costs off)
select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,
  lateral (select ss1.* from text_tbl t3 limit 1) as ss2
where t1.f1 = ss2.f1;
                                                                                                                                                                                                                                 QUERY PLAN                                                                                                                                                                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: t1._id, t1.f1, i8._id, i8.q1, i8.q2, (i8.q1), t2.f1, ((i8.q1)), (t2.f1)
   Join Filter: (t1.f1 = (t2.f1))
   ->  Nested Loop
         Output: t1._id, t1.f1, i8._id, i8.q1, i8.q2, (i8.q1), t2.f1
         ->  Foreign Scan
               Output: t1._id, t1.f1, i8._id, i8.q1, i8.q2
               Foreign Namespace: join_regress.text_tbl
               Query document: { "pipeline" : [ { "$lookup" : { "from" : "int8_tbl", "let" : {  }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$q2", { "$numberInt" : "123" } ] } } }, { "$project" : { "ref2" : "$_id", "ref3" : "$q1", "ref4" : "$q2" } } ], "as" : "int8_tbl" } }, { "$unwind" : { "path" : "$int8_tbl", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$f1", "int8_tbl" : { "$numberInt" : "1" } } } ] }
         ->  Foreign Scan on public.text_tbl t2
               Output: i8.q1, t2.f1
               Foreign Namespace: join_regress.text_tbl
               Query document: { "pipeline" : [ { "$project" : { "f1" : { "$numberInt" : "1" } } }, { "$limit" : { "$numberLong" : "1"} } ] }
   ->  Foreign Scan on public.text_tbl t3
         Output: (i8.q1), t2.f1
         Foreign Namespace: join_regress.text_tbl
         Query document: { "pipeline" : [ { "$limit" : { "$numberLong" : "1"} } ] }
(17 rows)

--Testcase 218:
select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,
  lateral (select ss1.* from text_tbl t3 limit 1) as ss2
where t1.f1 = ss2.f1;
 _id |  f1  | _id |        q1        | q2  |        q1        |  f1  |        q1        |  f1  
-----+------+-----+------------------+-----+------------------+------+------------------+------
   1 | doh! |   3 | 4567890123456789 | 123 | 4567890123456789 | doh! | 4567890123456789 | doh!
(1 row)

--Testcase 219:
explain (verbose, costs off)
select 1 from
  text_tbl as tt1
  inner join text_tbl as tt2 on (tt1.f1 = 'foo')
  left join text_tbl as tt3 on (tt3.f1 = 'foo')
  left join text_tbl as tt4 on (tt3.f1 = tt4.f1),
  lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1
where tt1.f1 = ss1.c0;
                                                                                                                                                                                                                                             QUERY PLAN                                                                                                                                                                                                                                             
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: 1
   ->  Nested Loop Left Join
         Output: tt1.f1, tt4.f1
         ->  Nested Loop
               Output: tt1.f1
               ->  Foreign Scan on public.text_tbl tt1
                     Output: tt1._id, tt1.f1
                     Foreign Namespace: join_regress.text_tbl
                     Query document: { "pipeline" : [ { "$match" : { "f1" : { "$eq" : "foo" } } }, { "$project" : { "f1" : { "$numberInt" : "1" } } } ] }
               ->  Foreign Scan on public.text_tbl tt2
                     Output: tt2._id, tt2.f1
                     Foreign Namespace: join_regress.text_tbl
                     Query document: { "pipeline" : [  ] }
         ->  Foreign Scan
               Output: tt4.f1
               Foreign Namespace: join_regress.text_tbl
               Query document: { "pipeline" : [ { "$lookup" : { "from" : "text_tbl", "let" : { "ref2" : "$f1" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$eq" : [ "$$ref2", "$f1" ] }, { "$eq" : [ "$f1", "foo" ] } ] } } }, { "$project" : { "ref0" : "$f1" } } ], "as" : "text_tbl" } }, { "$unwind" : { "path" : "$text_tbl", "preserveNullAndEmptyArrays" : true } }, { "$match" : { "f1" : { "$eq" : "foo" } } }, { "$project" : { "text_tbl" : { "$numberInt" : "1" } } } ] }
   ->  Subquery Scan on ss1
         Output: ss1.c0
         Filter: (ss1.c0 = 'foo'::text)
         ->  Foreign Scan on public.text_tbl tt5
               Output: tt4.f1
               Foreign Namespace: join_regress.text_tbl
               Query document: { "pipeline" : [ { "$limit" : { "$numberLong" : "1"} } ] }
(25 rows)

--Testcase 220:
select 1 from
  text_tbl as tt1
  inner join text_tbl as tt2 on (tt1.f1 = 'foo')
  left join text_tbl as tt3 on (tt3.f1 = 'foo')
  left join text_tbl as tt4 on (tt3.f1 = tt4.f1),
  lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1
where tt1.f1 = ss1.c0;
 ?column? 
----------
(0 rows)

--
-- check a case in which a PlaceHolderVar forces join order
--
--Testcase 221:
explain (verbose, costs off)
select ss2.* from
  int4_tbl i41
  left join int8_tbl i8
    join (select i42.f1 as c1, i43.f1 as c2, 42 as c3
          from int4_tbl i42, int4_tbl i43) ss1
    on i8.q1 = ss1.c2
  on i41.f1 = ss1.c1,
  lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
where ss1.c2 = 0;
                                                                                                                QUERY PLAN                                                                                                                
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: (i41._id), (i41.f1), (i8._id), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
   ->  Nested Loop
         Output: i41._id, i41.f1, i42.f1, i8._id, i8.q1, i8.q2, i43.f1, 42
         ->  Nested Loop
               Output: i41._id, i41.f1, i42.f1, i8._id, i8.q1, i8.q2
               ->  Merge Join
                     Output: i41._id, i41.f1, i42.f1
                     Merge Cond: (i41.f1 = i42.f1)
                     ->  Sort
                           Output: i41._id, i41.f1
                           Sort Key: i41.f1
                           ->  Foreign Scan on public.int4_tbl i41
                                 Output: i41._id, i41.f1
                                 Foreign Namespace: join_regress.int4_tbl
                                 Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "f1" : { "$numberInt" : "1" } } } ] }
                     ->  Sort
                           Output: i42.f1
                           Sort Key: i42.f1
                           ->  Foreign Scan on public.int4_tbl i42
                                 Output: i42.f1
                                 Foreign Namespace: join_regress.int4_tbl
                                 Query document: { "pipeline" : [ { "$project" : { "f1" : { "$numberInt" : "1" } } } ] }
               ->  Foreign Scan on public.int8_tbl i8
                     Output: i8._id, i8.q1, i8.q2
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$match" : { "q1" : { "$eq" : { "$numberInt" : "0" } } } }, { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
         ->  Foreign Scan on public.int4_tbl i43
               Output: i43._id, i43.f1
               Foreign Namespace: join_regress.int4_tbl
               Query document: { "pipeline" : [ { "$match" : { "f1" : { "$eq" : { "$numberInt" : "0" } } } }, { "$project" : { "f1" : { "$numberInt" : "1" } } } ] }
   ->  Foreign Scan on public.text_tbl
         Output: i41._id, i41.f1, i8._id, i8.q1, i8.q2, i42.f1, i43.f1, (42)
         Foreign Namespace: join_regress.text_tbl
         Query document: { "pipeline" : [ { "$limit" : { "$numberLong" : "1"} } ] }
(35 rows)

--Testcase 222:
select ss2.* from
  int4_tbl i41
  left join int8_tbl i8
    join (select i42.f1 as c1, i43.f1 as c2, 42 as c3
          from int4_tbl i42, int4_tbl i43) ss1
    on i8.q1 = ss1.c2
  on i41.f1 = ss1.c1,
  lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
where ss1.c2 = 0;
 _id | f1 | _id | q1 | q2 | c1 | c2 | c3 
-----+----+-----+----+----+----+----+----
(0 rows)

--
-- test successful handling of full join underneath left join (bug #14105)
--
--Testcase 223:
explain (costs off)
select * from
  (select 1 as id) as xx
  left join
    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))
  on (xx.id = coalesce(yy.id));
                     QUERY PLAN                     
----------------------------------------------------
 Nested Loop Left Join
   ->  Result
   ->  Hash Full Join
         Hash Cond: (a1.unique1 = (1))
         Filter: (1 = COALESCE((1)))
         ->  Foreign Scan on tenk1 a1
               Foreign Namespace: join_regress.tenk
         ->  Hash
               ->  Result
(9 rows)

--Testcase 224:
select * from
  (select 1 as id) as xx
  left join
    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))
  on (xx.id = coalesce(yy.id));
 id | _id  | unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | id 
----+------+---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+----
  1 | 2839 |       1 |    2838 |   1 |    1 |   1 |      1 |       1 |        1 |           1 |         1 |        1 |   2 |    3 | BAAAAA   | EFEAAA   | OOOOxx  |  1
(1 row)

--
-- test ability to push constants through outer join clauses
--
--Testcase 225:
explain (costs off)
  select * from int4_tbl a left join tenk1 b on f1 = unique2 where f1 = 0;
                 QUERY PLAN                 
--------------------------------------------
 Foreign Scan
   Foreign Namespace: join_regress.int4_tbl
(2 rows)

--Testcase 226:
explain (costs off)
  select * from tenk1 a full join tenk1 b using(unique2) where unique2 = 42;
                     QUERY PLAN                     
----------------------------------------------------
 Hash Full Join
   Hash Cond: (a.unique2 = b.unique2)
   ->  Foreign Scan on tenk1 a
         Foreign Namespace: join_regress.tenk
   ->  Hash
         ->  Foreign Scan on tenk1 b
               Foreign Namespace: join_regress.tenk
(7 rows)

--
-- test join removal
--
begin;
--Testcase 227:
CREATE FOREIGN TABLE a1 (_id int4, id int, b_id int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'a1');
--Testcase 228:
CREATE FOREIGN TABLE b1 (_id int4, id int, c_id int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'b1');
--Testcase 229:
CREATE FOREIGN TABLE c1 (_id int4, id int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'c1');
--Testcase 230:
CREATE FOREIGN TABLE d1 (_id int4, a int, b int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'd1');
-- all three cases should be optimizable into a simple seqscan
--Testcase 231:
explain (costs off) SELECT a1.* FROM a1 LEFT JOIN b1 ON a1.b_id = b1.id;
              QUERY PLAN              
--------------------------------------
 Foreign Scan
   Foreign Namespace: join_regress.a1
(2 rows)

--Testcase 232:
explain (costs off) SELECT b1.* FROM b1 LEFT JOIN c1 ON b1.c_id = c1.id;
              QUERY PLAN              
--------------------------------------
 Foreign Scan
   Foreign Namespace: join_regress.b1
(2 rows)

--Testcase 233:
explain (costs off)
  SELECT a1.* FROM a1 LEFT JOIN (b1 left join c1 on b1.c_id = c1.id)
  ON (a1.b_id = b1.id);
              QUERY PLAN              
--------------------------------------
 Foreign Scan
   Foreign Namespace: join_regress.a1
(2 rows)

-- check optimization of outer join within another special join
--Testcase 234:
explain (costs off)
select id from a1 where id in (
	select b1.id from b1 left join c1 on b1.id = c1.id
);
                    QUERY PLAN                    
--------------------------------------------------
 Hash Semi Join
   Hash Cond: (a1.id = b1.id)
   ->  Foreign Scan on a1
         Foreign Namespace: join_regress.a1
   ->  Hash
         ->  Foreign Scan
               Foreign Namespace: join_regress.b1
(7 rows)

-- check that join removal works for a left join when joining a subquery
-- that is guaranteed to be unique by its GROUP BY clause
--Testcase 235:
explain (costs off)
select d1.* from d1 left join (select * from b1 group by b1.id, b1.c_id, b1._id) s
  on d1.a = s.id and d1.b = s.c_id;
                       QUERY PLAN                       
--------------------------------------------------------
 Hash Left Join
   Hash Cond: ((d1.a = s.id) AND (d1.b = s.c_id))
   ->  Foreign Scan on d1
         Foreign Namespace: join_regress.d1
   ->  Hash
         ->  Subquery Scan on s
               ->  Foreign Scan
                     Foreign Namespace: join_regress.b1
(8 rows)

-- similarly, but keying off a DISTINCT clause
--Testcase 236:
explain (costs off)
select d1.* from d1 left join (select distinct * from b1) s
  on d1.a = s.id and d1.b = s.c_id;
                          QUERY PLAN                          
--------------------------------------------------------------
 Hash Left Join
   Hash Cond: ((d1.a = s.id) AND (d1.b = s.c_id))
   ->  Foreign Scan on d1
         Foreign Namespace: join_regress.d1
   ->  Hash
         ->  Subquery Scan on s
               ->  HashAggregate
                     Group Key: b1._id, b1.id, b1.c_id
                     ->  Foreign Scan on b1
                           Foreign Namespace: join_regress.b1
(10 rows)

-- join removal is not possible when the GROUP BY contains a column that is
-- not in the join condition.  (Note: as of 9.6, we notice that b.id is a
-- primary key and so drop b.c_id from the GROUP BY of the resulting plan;
-- but this happens too late for join removal in the outer plan level.)
--Testcase 237:
explain (costs off)
select d1.* from d1 left join (select * from b1 group by b1.id, b1.c_id, b1._id) s
  on d1.a = s.id;
                       QUERY PLAN                       
--------------------------------------------------------
 Hash Left Join
   Hash Cond: (d1.a = s.id)
   ->  Foreign Scan on d1
         Foreign Namespace: join_regress.d1
   ->  Hash
         ->  Subquery Scan on s
               ->  Foreign Scan
                     Foreign Namespace: join_regress.b1
(8 rows)

-- similarly, but keying off a DISTINCT clause
--Testcase 238:
explain (costs off)
select d1.* from d1 left join (select distinct * from b1) s
  on d1.a = s.id;
                          QUERY PLAN                          
--------------------------------------------------------------
 Hash Left Join
   Hash Cond: (d1.a = s.id)
   ->  Foreign Scan on d1
         Foreign Namespace: join_regress.d1
   ->  Hash
         ->  Subquery Scan on s
               ->  HashAggregate
                     Group Key: b1._id, b1.id, b1.c_id
                     ->  Foreign Scan on b1
                           Foreign Namespace: join_regress.b1
(10 rows)

-- check join removal works when uniqueness of the join condition is enforced
-- by a UNION
--Testcase 239:
explain (costs off)
select d1.* from d1 left join (select id from a1 union select id from b1) s
  on d1.a = s.id;
              QUERY PLAN              
--------------------------------------
 Foreign Scan on d1
   Foreign Namespace: join_regress.d1
(2 rows)

-- check join removal with a cross-type comparison operator
--Testcase 240:
explain (costs off)
select i8.* from int8_tbl i8 left join (select f1 from int4_tbl group by f1) i4
  on i8.q1 = i4.f1;
                 QUERY PLAN                 
--------------------------------------------
 Foreign Scan on int8_tbl i8
   Foreign Namespace: join_regress.int8_tbl
(2 rows)

-- check join removal with lateral references
--Testcase 241:
explain (costs off)
select 1 from (select a1.id FROM a1 left join b1 on a1.b_id = b1.id) q,
			  lateral generate_series(1, q.id) gs(i) where q.id = gs.i;
                 QUERY PLAN                 
--------------------------------------------
 Nested Loop
   ->  Foreign Scan
         Foreign Namespace: join_regress.a1
   ->  Function Scan on generate_series gs
         Filter: (a1.id = i)
(5 rows)

rollback;
--Testcase 242:
CREATE FOREIGN TABLE parent (_id int4, k int, pd int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'parent');
--Testcase 243:
CREATE FOREIGN TABLE child (_id int4, k int, cd int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'child');
-- this case is optimizable
--Testcase 244:
select p.* from parent p left join child c on (p.k = c.k);
 _id | k | pd 
-----+---+----
   1 | 1 | 10
   2 | 2 | 20
   3 | 3 | 30
(3 rows)

--Testcase 245:
explain (costs off)
  select p.* from parent p left join child c on (p.k = c.k);
                QUERY PLAN                
------------------------------------------
 Foreign Scan
   Foreign Namespace: join_regress.parent
(2 rows)

-- this case is not
--Testcase 246:
select p.*, linked from parent p
  left join (select c.*, true as linked from child c) as ss
  on (p.k = ss.k);
 _id | k | pd | linked 
-----+---+----+--------
   1 | 1 | 10 | t
   2 | 2 | 20 | 
   3 | 3 | 30 | 
(3 rows)

--Testcase 247:
explain (costs off)
  select p.*, linked from parent p
    left join (select c.*, true as linked from child c) as ss
    on (p.k = ss.k);
                      QUERY PLAN                      
------------------------------------------------------
 Merge Left Join
   Merge Cond: (p.k = c.k)
   ->  Sort
         Sort Key: p.k
         ->  Foreign Scan on parent p
               Foreign Namespace: join_regress.parent
   ->  Sort
         Sort Key: c.k
         ->  Foreign Scan on child c
               Foreign Namespace: join_regress.child
(10 rows)

-- check for a 9.0rc1 bug: join removal breaks pseudoconstant qual handling
--Testcase 248:
select p.* from
  parent p left join child c on (p.k = c.k)
  where p.k = 1 and p.k = 2;
 _id | k | pd 
-----+---+----
(0 rows)

--Testcase 249:
explain (costs off)
select p.* from
  parent p left join child c on (p.k = c.k)
  where p.k = 1 and p.k = 2;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

--Testcase 250:
select p.* from
  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
  where p.k = 1 and p.k = 2;
 _id | k | pd 
-----+---+----
(0 rows)

--Testcase 251:
explain (costs off)
select p.* from
  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
  where p.k = 1 and p.k = 2;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

-- bug 5255: this is not optimizable by join removal
begin;
--Testcase 252:
CREATE FOREIGN TABLE a2 (_id int4, id int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'a2');
--Testcase 253:
CREATE FOREIGN TABLE b2 (_id int4, id int, a_id int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'b2');
--Testcase 254:
SELECT * FROM b2 LEFT JOIN a2 ON (b2.a_id = a2.id) WHERE (a2.id IS NULL OR a2.id > 0);
 _id | id | a_id | _id | id 
-----+----+------+-----+----
   2 |  1 |      |     |   
(1 row)

--Testcase 255:
SELECT b2.* FROM b2 LEFT JOIN a2 ON (b2.a_id = a2.id) WHERE (a2.id IS NULL OR a2.id > 0);
 _id | id | a_id 
-----+----+------
   2 |  1 |     
(1 row)

rollback;
-- another join removal bug: this is not optimizable, either
begin;
--Testcase 256:
CREATE FOREIGN TABLE innertab (_id int4, id int8, dat1 int8)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'innertab');
--Testcase 257:
SELECT * FROM
    (SELECT 1 AS x) ss1
  LEFT JOIN
    (SELECT q1, q2, COALESCE(dat1, q1) AS y
     FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss2
  ON true;
 x |        q1        |        q2         |        y         
---+------------------+-------------------+------------------
 1 |              123 |               456 |              123
 1 |              123 |  4567890123456789 |              123
 1 | 4567890123456789 |               123 |               42
 1 | 4567890123456789 |  4567890123456789 | 4567890123456789
 1 | 4567890123456789 | -4567890123456789 | 4567890123456789
(5 rows)

rollback;
-- test case to expose miscomputation of required relid set for a PHV
explain (verbose, costs off)
select i8.*, ss.v, t.unique2
  from int8_tbl i8
    left join int4_tbl i4 on i4.f1 = 1
    left join lateral (select i4.f1 + 1 as v) as ss on true
    left join tenk1 t on t.unique2 = ss.v
where q2 = 456;
                                                                                                                                                                                                                                                       QUERY PLAN                                                                                                                                                                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Hash Right Join
   Output: i8._id, i8.q1, i8.q2, ((i4.f1 + 1)), t.unique2
   Hash Cond: (t.unique2 = ((i4.f1 + 1)))
   ->  Foreign Scan on public.tenk1 t
         Output: t._id, t.unique1, t.unique2, t.two, t.four, t.ten, t.twenty, t.hundred, t.thousand, t.twothousand, t.fivethous, t.tenthous, t.odd, t.even, t.stringu1, t.stringu2, t.string4
         Foreign Namespace: join_regress.tenk
         Query document: { "pipeline" : [ { "$project" : { "unique2" : { "$numberInt" : "1" } } } ] }
   ->  Hash
         Output: i8._id, i8.q1, i8.q2, ((i4.f1 + 1))
         ->  Foreign Scan
               Output: i8._id, i8.q1, i8.q2, (i4.f1 + 1)
               Foreign Namespace: join_regress.int8_tbl
               Query document: { "pipeline" : [ { "$lookup" : { "from" : "int4_tbl", "let" : {  }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$f1", { "$numberInt" : "1" } ] } } }, { "$project" : { "ref3" : "$f1" } } ], "as" : "int4_tbl" } }, { "$unwind" : { "path" : "$int4_tbl", "preserveNullAndEmptyArrays" : true } }, { "$match" : { "q2" : { "$eq" : { "$numberInt" : "456" } } } }, { "$project" : { "ref0" : "$_id", "ref1" : "$q1", "ref2" : "$q2", "int4_tbl" : { "$numberInt" : "1" } } } ] }
(13 rows)

select i8.*, ss.v, t.unique2
  from int8_tbl i8
    left join int4_tbl i4 on i4.f1 = 1
    left join lateral (select i4.f1 + 1 as v) as ss on true
    left join tenk1 t on t.unique2 = ss.v
where q2 = 456;
 _id | q1  | q2  | v | unique2 
-----+-----+-----+---+---------
   1 | 123 | 456 |   |        
(1 row)

-- and check a related issue where we miscompute required relids for
-- a PHV that's been translated to a child rel
create temp table parttbl (_id name, a integer primary key) partition by range (a);
create foreign table parttbl1 (_id name, a integer)
  server mongo_server options (database 'join_regress', collection 'parttbl1');
alter table parttbl attach partition parttbl1 for values from (1) to (100);
ERROR:  cannot attach a permanent relation as partition of temporary relation "parttbl"
-- cannot insert via parent table
insert into parttbl1(a) values (11), (12);
explain (costs off)
select * from
  (select *, 12 as phv from parttbl) as ss
  right join int4_tbl on true
where ss.a = ss.phv and f1 = 0;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

select * from
  (select *, 12 as phv from parttbl) as ss
  right join int4_tbl on true
where ss.a = ss.phv and f1 = 0;
 _id | a | phv | _id | f1 
-----+---+-----+-----+----
(0 rows)

delete from parttbl1;
delete from parttbl;
drop foreign table parttbl1;
drop table parttbl;
-- lateral injecting a strange outer join condition
--Testcase 258:
explain (costs off)
  select * from int8_tbl a,
    int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
      on x.q2 = ss.z
  order by a.q1, a.q2, x.q1, x.q2, ss.z;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Sort Key: a.q1, a.q2, x.q1, x.q2, (a.q1)
   ->  Nested Loop
         ->  Foreign Scan on int8_tbl a
               Foreign Namespace: join_regress.int8_tbl
         ->  Merge Left Join
               Merge Cond: (x.q2 = (a.q1))
               ->  Sort
                     Sort Key: x.q2
                     ->  Foreign Scan on int8_tbl x
                           Foreign Namespace: join_regress.int8_tbl
               ->  Sort
                     Sort Key: (a.q1)
                     ->  Foreign Scan on int4_tbl y
                           Foreign Namespace: join_regress.int4_tbl
(15 rows)

--Testcase 259:
select * from int8_tbl a,
  int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
    on x.q2 = ss.z
  order by a.q1, a.q2, x.q1, x.q2, ss.z;
 _id |        q1        |        q2         | _id |        q1        |        q2         |        z         
-----+------------------+-------------------+-----+------------------+-------------------+------------------
   1 |              123 |               456 |   1 |              123 |               456 |                 
   1 |              123 |               456 |   2 |              123 |  4567890123456789 |                 
   1 |              123 |               456 |   5 | 4567890123456789 | -4567890123456789 |                 
   1 |              123 |               456 |   3 | 4567890123456789 |               123 |              123
   1 |              123 |               456 |   3 | 4567890123456789 |               123 |              123
   1 |              123 |               456 |   3 | 4567890123456789 |               123 |              123
   1 |              123 |               456 |   3 | 4567890123456789 |               123 |              123
   1 |              123 |               456 |   3 | 4567890123456789 |               123 |              123
   1 |              123 |               456 |   4 | 4567890123456789 |  4567890123456789 |                 
   2 |              123 |  4567890123456789 |   1 |              123 |               456 |                 
   2 |              123 |  4567890123456789 |   2 |              123 |  4567890123456789 |                 
   2 |              123 |  4567890123456789 |   5 | 4567890123456789 | -4567890123456789 |                 
   2 |              123 |  4567890123456789 |   3 | 4567890123456789 |               123 |              123
   2 |              123 |  4567890123456789 |   3 | 4567890123456789 |               123 |              123
   2 |              123 |  4567890123456789 |   3 | 4567890123456789 |               123 |              123
   2 |              123 |  4567890123456789 |   3 | 4567890123456789 |               123 |              123
   2 |              123 |  4567890123456789 |   3 | 4567890123456789 |               123 |              123
   2 |              123 |  4567890123456789 |   4 | 4567890123456789 |  4567890123456789 |                 
   5 | 4567890123456789 | -4567890123456789 |   1 |              123 |               456 |                 
   5 | 4567890123456789 | -4567890123456789 |   2 |              123 |  4567890123456789 | 4567890123456789
   5 | 4567890123456789 | -4567890123456789 |   2 |              123 |  4567890123456789 | 4567890123456789
   5 | 4567890123456789 | -4567890123456789 |   2 |              123 |  4567890123456789 | 4567890123456789
   5 | 4567890123456789 | -4567890123456789 |   2 |              123 |  4567890123456789 | 4567890123456789
   5 | 4567890123456789 | -4567890123456789 |   2 |              123 |  4567890123456789 | 4567890123456789
   5 | 4567890123456789 | -4567890123456789 |   5 | 4567890123456789 | -4567890123456789 |                 
   5 | 4567890123456789 | -4567890123456789 |   3 | 4567890123456789 |               123 |                 
   5 | 4567890123456789 | -4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   5 | 4567890123456789 | -4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   5 | 4567890123456789 | -4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   5 | 4567890123456789 | -4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   5 | 4567890123456789 | -4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   3 | 4567890123456789 |               123 |   1 |              123 |               456 |                 
   3 | 4567890123456789 |               123 |   2 |              123 |  4567890123456789 | 4567890123456789
   3 | 4567890123456789 |               123 |   2 |              123 |  4567890123456789 | 4567890123456789
   3 | 4567890123456789 |               123 |   2 |              123 |  4567890123456789 | 4567890123456789
   3 | 4567890123456789 |               123 |   2 |              123 |  4567890123456789 | 4567890123456789
   3 | 4567890123456789 |               123 |   2 |              123 |  4567890123456789 | 4567890123456789
   3 | 4567890123456789 |               123 |   5 | 4567890123456789 | -4567890123456789 |                 
   3 | 4567890123456789 |               123 |   3 | 4567890123456789 |               123 |                 
   3 | 4567890123456789 |               123 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   3 | 4567890123456789 |               123 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   3 | 4567890123456789 |               123 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   3 | 4567890123456789 |               123 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   3 | 4567890123456789 |               123 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   1 |              123 |               456 |                 
   4 | 4567890123456789 |  4567890123456789 |   2 |              123 |  4567890123456789 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   2 |              123 |  4567890123456789 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   2 |              123 |  4567890123456789 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   2 |              123 |  4567890123456789 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   2 |              123 |  4567890123456789 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   5 | 4567890123456789 | -4567890123456789 |                 
   4 | 4567890123456789 |  4567890123456789 |   3 | 4567890123456789 |               123 |                 
   4 | 4567890123456789 |  4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
(57 rows)

-- lateral references requiring pullup
--Testcase 260:
select * from
  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (values(x.q1,y.q1,y.q2)) v(xq1,yq1,yq2);
 _id |        q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
-----+------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
   5 | 4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
   3 | 4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
   3 | 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
   1 |              123 |               456 |                  |                   |              123 |                  |                  
   2 |              123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
   2 |              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
   2 |              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
   4 | 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
   4 | 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
   4 | 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
(10 rows)

--Testcase 261:
select * from
  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
 _id |        q1        |        q2         |        q1        |        q2         |       xq1        |       yq1        |        yq2        
-----+------------------+-------------------+------------------+-------------------+------------------+------------------+-------------------
   5 | 4567890123456789 | -4567890123456789 |                  |                   | 4567890123456789 |                  |                  
   3 | 4567890123456789 |               123 |              123 |               456 | 4567890123456789 |              123 |               456
   3 | 4567890123456789 |               123 |              123 |  4567890123456789 | 4567890123456789 |              123 |  4567890123456789
   1 |              123 |               456 |                  |                   |              123 |                  |                  
   2 |              123 |  4567890123456789 | 4567890123456789 |               123 |              123 | 4567890123456789 |               123
   2 |              123 |  4567890123456789 | 4567890123456789 |  4567890123456789 |              123 | 4567890123456789 |  4567890123456789
   2 |              123 |  4567890123456789 | 4567890123456789 | -4567890123456789 |              123 | 4567890123456789 | -4567890123456789
   4 | 4567890123456789 |  4567890123456789 | 4567890123456789 |               123 | 4567890123456789 | 4567890123456789 |               123
   4 | 4567890123456789 |  4567890123456789 | 4567890123456789 |  4567890123456789 | 4567890123456789 | 4567890123456789 |  4567890123456789
   4 | 4567890123456789 |  4567890123456789 | 4567890123456789 | -4567890123456789 | 4567890123456789 | 4567890123456789 | -4567890123456789
(10 rows)

--Testcase 262:
select x.* from
  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
 _id |        q1        |        q2         
-----+------------------+-------------------
   1 |              123 |               456
   2 |              123 |  4567890123456789
   2 |              123 |  4567890123456789
   2 |              123 |  4567890123456789
   3 | 4567890123456789 |               123
   3 | 4567890123456789 |               123
   4 | 4567890123456789 |  4567890123456789
   4 | 4567890123456789 |  4567890123456789
   4 | 4567890123456789 |  4567890123456789
   5 | 4567890123456789 | -4567890123456789
(10 rows)

--Testcase 263:
select v.* from
  (int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1)
  left join int4_tbl z on z.f1 = x.q2,
  lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);
        vx         |        vy         
-------------------+-------------------
  4567890123456789 |                  
 -4567890123456789 |                  
  4567890123456789 |               123
               123 |               456
  4567890123456789 |               123
               123 |  4567890123456789
               123 |                  
               456 |                  
               123 |  4567890123456789
  4567890123456789 |               123
               123 |  4567890123456789
  4567890123456789 |  4567890123456789
               123 |  4567890123456789
  4567890123456789 | -4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |               123
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 | -4567890123456789
(20 rows)

--Testcase 264:
select v.* from
  (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
  left join int4_tbl z on z.f1 = x.q2,
  lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);
        vx         |        vy         
-------------------+-------------------
  4567890123456789 |                  
 -4567890123456789 |                  
  4567890123456789 |               123
               123 |               456
  4567890123456789 |               123
               123 |  4567890123456789
               123 |                  
               456 |                  
               123 |  4567890123456789
  4567890123456789 |               123
               123 |  4567890123456789
  4567890123456789 |  4567890123456789
               123 |  4567890123456789
  4567890123456789 | -4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |               123
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 | -4567890123456789
(20 rows)

--Testcase 265:
select v.* from
  (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
  left join int4_tbl z on z.f1 = x.q2,
  lateral (select x.q1,y.q1 from onerow union all select x.q2,y.q2 from onerow) v(vx,vy);
        vx         |        vy         
-------------------+-------------------
  4567890123456789 |                  
 -4567890123456789 |                  
  4567890123456789 |               123
               123 |               456
  4567890123456789 |               123
               123 |  4567890123456789
               123 |                  
               456 |                  
               123 |  4567890123456789
  4567890123456789 |               123
               123 |  4567890123456789
  4567890123456789 |  4567890123456789
               123 |  4567890123456789
  4567890123456789 | -4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |               123
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 |  4567890123456789
  4567890123456789 | -4567890123456789
(20 rows)

--Testcase 266:
explain (verbose, costs off)
select * from
  int8_tbl a left join
  lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: a._id, a.q1, a.q2, b._id, b.q1, b.q2, (a.q2)
   ->  Foreign Scan on public.int8_tbl a
         Output: a._id, a.q1, a.q2
         Foreign Namespace: join_regress.int8_tbl
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
   ->  Foreign Scan on public.int8_tbl b
         Output: b._id, b.q1, b.q2, a.q2
         Filter: (a.q2 = b.q1)
         Foreign Namespace: join_regress.int8_tbl
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
(11 rows)

--Testcase 267:
select * from
  int8_tbl a left join
  lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
 _id |        q1        |        q2         | _id |        q1        |        q2         |        x         
-----+------------------+-------------------+-----+------------------+-------------------+------------------
   1 |              123 |               456 |     |                  |                   |                 
   2 |              123 |  4567890123456789 |   3 | 4567890123456789 |               123 | 4567890123456789
   2 |              123 |  4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   2 |              123 |  4567890123456789 |   5 | 4567890123456789 | -4567890123456789 | 4567890123456789
   3 | 4567890123456789 |               123 |   1 |              123 |               456 |              123
   3 | 4567890123456789 |               123 |   2 |              123 |  4567890123456789 |              123
   4 | 4567890123456789 |  4567890123456789 |   3 | 4567890123456789 |               123 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   5 | 4567890123456789 | -4567890123456789 | 4567890123456789
   5 | 4567890123456789 | -4567890123456789 |     |                  |                   |                 
(10 rows)

--Testcase 268:
explain (verbose, costs off)
select * from
  int8_tbl a left join
  lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: a._id, a.q1, a.q2, b._id, b.q1, b.q2, (COALESCE(a.q2, '42'::bigint))
   ->  Foreign Scan on public.int8_tbl a
         Output: a._id, a.q1, a.q2
         Foreign Namespace: join_regress.int8_tbl
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
   ->  Foreign Scan on public.int8_tbl b
         Output: b._id, b.q1, b.q2, COALESCE(a.q2, '42'::bigint)
         Filter: (a.q2 = b.q1)
         Foreign Namespace: join_regress.int8_tbl
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
(11 rows)

--Testcase 269:
select * from
  int8_tbl a left join
  lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
 _id |        q1        |        q2         | _id |        q1        |        q2         |        x         
-----+------------------+-------------------+-----+------------------+-------------------+------------------
   1 |              123 |               456 |     |                  |                   |                 
   2 |              123 |  4567890123456789 |   3 | 4567890123456789 |               123 | 4567890123456789
   2 |              123 |  4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   2 |              123 |  4567890123456789 |   5 | 4567890123456789 | -4567890123456789 | 4567890123456789
   3 | 4567890123456789 |               123 |   1 |              123 |               456 |              123
   3 | 4567890123456789 |               123 |   2 |              123 |  4567890123456789 |              123
   4 | 4567890123456789 |  4567890123456789 |   3 | 4567890123456789 |               123 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   4 | 4567890123456789 |  4567890123456789 | 4567890123456789
   4 | 4567890123456789 |  4567890123456789 |   5 | 4567890123456789 | -4567890123456789 | 4567890123456789
   5 | 4567890123456789 | -4567890123456789 |     |                  |                   |                 
(10 rows)

-- lateral can result in join conditions appearing below their
-- real semantic level
--Testcase 270:
CREATE FOREIGN TABLE INT2_TBL(_id int4, f1 int2) 
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'int2_tbl');
--Testcase 271:
explain (verbose, costs off)
select * from int4_tbl i left join
  lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
                                                                                                                                                                                                                  QUERY PLAN                                                                                                                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan
   Output: i._id, i.f1, j._id, j.f1
   Foreign Namespace: join_regress.int4_tbl
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "int2_tbl", "let" : { "ref2" : "$f1" }, "pipeline" : [ { "$match" : { "$expr" : { "$eq" : [ "$$ref2", "$f1" ] } } }, { "$project" : { "ref2" : "$_id", "ref3" : "$f1" } } ], "as" : "int2_tbl" } }, { "$unwind" : { "path" : "$int2_tbl", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$f1", "int2_tbl" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 272:
select * from int4_tbl i left join
  lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
 _id |     f1      | _id | f1 
-----+-------------+-----+----
   1 |           0 |   1 |  0
   2 |      123456 |     |   
   3 |     -123456 |     |   
   4 |  2147483647 |     |   
   5 | -2147483647 |     |   
(5 rows)

--Testcase 273:
explain (verbose, costs off)
select * from int4_tbl i left join
  lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: i._id, i.f1, (COALESCE(i.*))
   ->  Foreign Scan on public.int4_tbl i
         Output: i._id, i.f1, i.*
         Foreign Namespace: join_regress.int4_tbl
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "f1" : { "$numberInt" : "1" } } } ] }
   ->  Foreign Scan on public.int2_tbl j
         Output: j.f1, COALESCE(i.*)
         Filter: (i.f1 = j.f1)
         Foreign Namespace: join_regress.int2_tbl
         Query document: { "pipeline" : [ { "$project" : { "f1" : { "$numberInt" : "1" } } } ] }
(11 rows)

--Testcase 274:
select * from int4_tbl i left join
  lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
 _id |     f1      | coalesce 
-----+-------------+----------
   1 |           0 | (1,0)
   2 |      123456 | 
   3 |     -123456 | 
   4 |  2147483647 | 
   5 | -2147483647 | 
(5 rows)

--Testcase 275:
explain (verbose, costs off)
select * from int4_tbl a,
  lateral (
    select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
  ) ss;
                                                                                 QUERY PLAN                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: a._id, a.f1, b._id, b.f1, c._id, c.q1, c.q2
   ->  Foreign Scan on public.int4_tbl a
         Output: a._id, a.f1
         Foreign Namespace: join_regress.int4_tbl
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "f1" : { "$numberInt" : "1" } } } ] }
   ->  Merge Left Join
         Output: b._id, b.f1, c._id, c.q1, c.q2
         Merge Cond: (b.f1 = c.q1)
         ->  Sort
               Output: b._id, b.f1
               Sort Key: b.f1
               ->  Foreign Scan on public.int4_tbl b
                     Output: b._id, b.f1
                     Foreign Namespace: join_regress.int4_tbl
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "f1" : { "$numberInt" : "1" } } } ] }
         ->  Sort
               Output: c._id, c.q1, c.q2
               Sort Key: c.q1
               ->  Foreign Scan on public.int8_tbl c
                     Output: c._id, c.q1, c.q2
                     Filter: (a.f1 = c.q2)
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
(24 rows)

--Testcase 276:
select * from int4_tbl a,
  lateral (
    select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
  ) ss;
 _id |     f1      | _id |     f1      | _id | q1 | q2 
-----+-------------+-----+-------------+-----+----+----
   1 |           0 |   5 | -2147483647 |     |    |   
   1 |           0 |   3 |     -123456 |     |    |   
   1 |           0 |   1 |           0 |     |    |   
   1 |           0 |   2 |      123456 |     |    |   
   1 |           0 |   4 |  2147483647 |     |    |   
   2 |      123456 |   5 | -2147483647 |     |    |   
   2 |      123456 |   3 |     -123456 |     |    |   
   2 |      123456 |   1 |           0 |     |    |   
   2 |      123456 |   2 |      123456 |     |    |   
   2 |      123456 |   4 |  2147483647 |     |    |   
   3 |     -123456 |   5 | -2147483647 |     |    |   
   3 |     -123456 |   3 |     -123456 |     |    |   
   3 |     -123456 |   1 |           0 |     |    |   
   3 |     -123456 |   2 |      123456 |     |    |   
   3 |     -123456 |   4 |  2147483647 |     |    |   
   4 |  2147483647 |   5 | -2147483647 |     |    |   
   4 |  2147483647 |   3 |     -123456 |     |    |   
   4 |  2147483647 |   1 |           0 |     |    |   
   4 |  2147483647 |   2 |      123456 |     |    |   
   4 |  2147483647 |   4 |  2147483647 |     |    |   
   5 | -2147483647 |   5 | -2147483647 |     |    |   
   5 | -2147483647 |   3 |     -123456 |     |    |   
   5 | -2147483647 |   1 |           0 |     |    |   
   5 | -2147483647 |   2 |      123456 |     |    |   
   5 | -2147483647 |   4 |  2147483647 |     |    |   
(25 rows)

-- lateral reference in a PlaceHolderVar evaluated at join level
--Testcase 277:
explain (verbose, costs off)
select * from
  int8_tbl c left join (
    int8_tbl a left join (select q1, coalesce(q2,42) as x from int8_tbl b) ss1
      on a.q2 = ss1.q1
    cross join
    lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
  ) on c.q2 = ss2.q1,
  lateral (select ss2.y offset 0) ss3;
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: c._id, c.q1, c.q2, a._id, a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint)), d.q1, (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)), ((COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)))
   ->  Hash Right Join
         Output: c._id, c.q1, c.q2, a._id, a.q1, a.q2, b.q1, d.q1, (COALESCE(b.q2, '42'::bigint)), (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))
         Hash Cond: (d.q1 = c.q2)
         ->  Nested Loop
               Output: a._id, a.q1, a.q2, b.q1, d.q1, (COALESCE(b.q2, '42'::bigint)), (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))
               ->  Merge Left Join
                     Output: a._id, a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint))
                     Merge Cond: (a.q2 = b.q1)
                     ->  Sort
                           Output: a._id, a.q1, a.q2
                           Sort Key: a.q2
                           ->  Foreign Scan on public.int8_tbl a
                                 Output: a._id, a.q1, a.q2
                                 Foreign Namespace: join_regress.int8_tbl
                                 Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
                     ->  Sort
                           Output: b.q1, (COALESCE(b.q2, '42'::bigint))
                           Sort Key: b.q1
                           ->  Foreign Scan on public.int8_tbl b
                                 Output: b.q1, COALESCE(b.q2, '42'::bigint)
                                 Foreign Namespace: join_regress.int8_tbl
                                 Query document: { "pipeline" : [ { "$project" : { "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
               ->  Foreign Scan on public.int8_tbl d
                     Output: d.q1, COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$project" : { "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
         ->  Hash
               Output: c._id, c.q1, c.q2
               ->  Foreign Scan on public.int8_tbl c
                     Output: c._id, c.q1, c.q2
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
   ->  Result
         Output: (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))
(36 rows)

-- case that breaks the old ph_may_need optimization
--Testcase 278:
explain (verbose, costs off)
select c.*,a.*,ss1.q1,ss2.q1,ss3.* from
  int8_tbl c left join (
    int8_tbl a left join
      (select q1, coalesce(q2,f1) as x from int8_tbl b, int4_tbl b2
       where q1 < f1) ss1
      on a.q2 = ss1.q1
    cross join
    lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
  ) on c.q2 = ss2.q1,
  lateral (select * from int4_tbl i where ss2.y > f1) ss3;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   Output: c._id, c.q1, c.q2, a._id, a.q1, a.q2, b.q1, d.q1, i._id, i.f1
   Join Filter: ((COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)) > i.f1)
   ->  Hash Right Join
         Output: c._id, c.q1, c.q2, a._id, a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))
         Hash Cond: (d.q1 = c.q2)
         ->  Nested Loop
               Output: a._id, a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))
               ->  Hash Right Join
                     Output: a._id, a.q1, a.q2, b.q1, (COALESCE(b.q2, (b2.f1)::bigint))
                     Hash Cond: (b.q1 = a.q2)
                     ->  Nested Loop
                           Output: b.q1, COALESCE(b.q2, (b2.f1)::bigint)
                           Join Filter: (b.q1 < b2.f1)
                           ->  Foreign Scan on public.int8_tbl b
                                 Output: b._id, b.q1, b.q2
                                 Foreign Namespace: join_regress.int8_tbl
                                 Query document: { "pipeline" : [ { "$project" : { "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
                           ->  Foreign Scan on public.int4_tbl b2
                                 Output: b2._id, b2.f1
                                 Foreign Namespace: join_regress.int4_tbl
                                 Query document: { "pipeline" : [ { "$project" : { "f1" : { "$numberInt" : "1" } } } ] }
                     ->  Hash
                           Output: a._id, a.q1, a.q2
                           ->  Foreign Scan on public.int8_tbl a
                                 Output: a._id, a.q1, a.q2
                                 Foreign Namespace: join_regress.int8_tbl
                                 Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
               ->  Foreign Scan on public.int8_tbl d
                     Output: d.q1, COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$project" : { "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
         ->  Hash
               Output: c._id, c.q1, c.q2
               ->  Foreign Scan on public.int8_tbl c
                     Output: c._id, c.q1, c.q2
                     Foreign Namespace: join_regress.int8_tbl
                     Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
   ->  Foreign Scan on public.int4_tbl i
         Output: i._id, i.f1
         Foreign Namespace: join_regress.int4_tbl
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "f1" : { "$numberInt" : "1" } } } ] }
(42 rows)

-- check dummy rels with lateral references (bug #15694)
--Testcase 279:
explain (verbose, costs off)
select * from int8_tbl i8 left join lateral
  (select *, i8.q2 from int4_tbl where false) ss on true;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: i8._id, i8.q1, i8.q2, _id, f1, (i8.q2)
   ->  Foreign Scan on public.int8_tbl i8
         Output: i8._id, i8.q1, i8.q2
         Foreign Namespace: join_regress.int8_tbl
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
   ->  Result
         Output: _id, f1, i8.q2
         One-Time Filter: false
(9 rows)

--Testcase 280:
explain (verbose, costs off)
select * from int8_tbl i8 left join lateral
  (select *, i8.q2 from int4_tbl i1, int4_tbl i2 where false) ss on true;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Left Join
   Output: i8._id, i8.q1, i8.q2, _id, f1, _id, f1, (i8.q2)
   ->  Foreign Scan on public.int8_tbl i8
         Output: i8._id, i8.q1, i8.q2
         Foreign Namespace: join_regress.int8_tbl
         Query document: { "pipeline" : [ { "$project" : { "_id" : { "$numberInt" : "1" }, "q1" : { "$numberInt" : "1" }, "q2" : { "$numberInt" : "1" } } } ] }
   ->  Result
         Output: _id, f1, _id, f1, i8.q2
         One-Time Filter: false
(9 rows)

--
-- test that foreign key join estimation performs sanely for outer joins
--
begin;
--Testcase 281:
CREATE FOREIGN TABLE fkest (_id int4, a int, b int, c int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'fkest');
--Testcase 282:
CREATE FOREIGN TABLE fkest1 (_id int4, a int, b int)
 SERVER mongo_server OPTIONS (database 'join_regress', collection 'fkest1');
--Testcase 283:
explain (costs off)
select *
from fkest f
  left join fkest1 f1 on f.a = f1.a and f.b = f1.b
  left join fkest1 f2 on f.a = f2.a and f.b = f2.b
  left join fkest1 f3 on f.a = f3.a and f.b = f3.b
where f.c = 1;
               QUERY PLAN                
-----------------------------------------
 Foreign Scan
   Foreign Namespace: join_regress.fkest
(2 rows)

rollback;
-- NULL comparison
-- PostgreSQL treats a NULL value is larger than a non-NULL value
-- But a NULL value is smaller than a non-NULL value in MongoDB
--Testcase 286:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND x.x2 < y.y2);
                                                                                                                                                                                                                                                     QUERY PLAN                                                                                                                                                                                                                                                     
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2
   Foreign Namespace: join_regress.x
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref3" : "$x2", "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$lt" : [ "$$ref3", "$y2" ] }, { "$eq" : [ "$$ref2", "$y1" ] } ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 287:
SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND x.x2 < y.y2);
 _id | x1 | x2 | _id | y1 | y2  
-----+----+----+-----+----+-----
   1 |  1 | 11 |   1 |  1 | 111
   2 |  2 | 22 |   2 |  2 | 222
   3 |  3 |    |   3 |  3 | 333
   4 |  4 | 44 |     |    |    
   5 |  5 |    |     |    |    
(5 rows)

--Testcase 288:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND x.x2 <= y.y2);
                                                                                                                                                                                                                                                     QUERY PLAN                                                                                                                                                                                                                                                      
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2
   Foreign Namespace: join_regress.x
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref3" : "$x2", "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$lte" : [ "$$ref3", "$y2" ] }, { "$eq" : [ "$$ref2", "$y1" ] } ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 289:
SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND x.x2 <= y.y2);
 _id | x1 | x2 | _id | y1 | y2  
-----+----+----+-----+----+-----
   1 |  1 | 11 |   1 |  1 | 111
   2 |  2 | 22 |   2 |  2 | 222
   3 |  3 |    |   3 |  3 | 333
   4 |  4 | 44 |     |    |    
   5 |  5 |    |     |    |    
(5 rows)

--Testcase 290:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND x.x2 > y.y2);
                                                                                                                                                                                                                                                     QUERY PLAN                                                                                                                                                                                                                                                     
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2
   Foreign Namespace: join_regress.x
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref3" : "$x2", "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$gt" : [ "$$ref3", "$y2" ] }, { "$eq" : [ "$$ref2", "$y1" ] } ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 291:
SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND x.x2 > y.y2);
 _id | x1 | x2 | _id | y1 | y2 
-----+----+----+-----+----+----
   1 |  1 | 11 |     |    |   
   2 |  2 | 22 |     |    |   
   3 |  3 |    |     |    |   
   4 |  4 | 44 |   4 |  4 |   
   5 |  5 |    |     |    |   
(5 rows)

--Testcase 292:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND x.x2 >= y.y2);
                                                                                                                                                                                                                                                     QUERY PLAN                                                                                                                                                                                                                                                      
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2
   Foreign Namespace: join_regress.x
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref3" : "$x2", "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$gte" : [ "$$ref3", "$y2" ] }, { "$eq" : [ "$$ref2", "$y1" ] } ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 293:
SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND x.x2 >= y.y2);
 _id | x1 | x2 | _id | y1 | y2 
-----+----+----+-----+----+----
   1 |  1 | 11 |     |    |   
   2 |  2 | 22 |     |    |   
   3 |  3 |    |     |    |   
   4 |  4 | 44 |   4 |  4 |   
   5 |  5 |    |     |    |   
(5 rows)

--Testcase 294:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND x.x2 != y.y2);
                                                                                                                                                                                                                                                     QUERY PLAN                                                                                                                                                                                                                                                     
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2
   Foreign Namespace: join_regress.x
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref3" : "$x2", "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$ne" : [ "$$ref3", "$y2" ] }, { "$eq" : [ "$$ref2", "$y1" ] } ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 295:
SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND x.x2 != y.y2);
 _id | x1 | x2 | _id | y1 | y2  
-----+----+----+-----+----+-----
   1 |  1 | 11 |   1 |  1 | 111
   2 |  2 | 22 |   2 |  2 | 222
   3 |  3 |    |   3 |  3 | 333
   4 |  4 | 44 |   4 |  4 |    
   5 |  5 |    |     |    |    
(5 rows)

--Testcase 296:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND x.x2 IS NOT NULL);
                                                                                                                                                                                                                                                    QUERY PLAN                                                                                                                                                                                                                                                    
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2
   Foreign Namespace: join_regress.x
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref3" : "$x2", "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$ne" : [ "$ref3", null ] }, { "$eq" : [ "$$ref2", "$y1" ] } ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 297:
SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND x.x2 IS NOT NULL);
 _id | x1 | x2 | _id | y1 | y2  
-----+----+----+-----+----+-----
   1 |  1 | 11 |   1 |  1 | 111
   2 |  2 | 22 |   2 |  2 | 222
   3 |  3 |    |   3 |  3 | 333
   4 |  4 | 44 |   4 |  4 |    
   5 |  5 |    |     |    |    
(5 rows)

--Testcase 298:
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND y.y2 IS NOT NULL);
                                                                                                                                                                                                                                           QUERY PLAN                                                                                                                                                                                                                                           
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan
   Output: x._id, x.x1, x.x2, y._id, y.y1, y.y2
   Foreign Namespace: join_regress.x
   Query document: { "pipeline" : [ { "$lookup" : { "from" : "y", "let" : { "ref2" : "$x1" }, "pipeline" : [ { "$match" : { "$expr" : { "$and" : [ { "$eq" : [ "$$ref2", "$y1" ] }, { "$ne" : [ "$y2", null ] } ] } } }, { "$project" : { "ref3" : "$_id", "ref4" : "$y1", "ref5" : "$y2" } } ], "as" : "y" } }, { "$unwind" : { "path" : "$y", "preserveNullAndEmptyArrays" : true } }, { "$project" : { "ref0" : "$_id", "ref1" : "$x1", "ref2" : "$x2", "y" : { "$numberInt" : "1" } } } ] }
(4 rows)

--Testcase 299:
SELECT * FROM x LEFT JOIN y ON (x.x1 = y.y1 AND y.y2 IS NOT NULL);
 _id | x1 | x2 | _id | y1 | y2  
-----+----+----+-----+----+-----
   1 |  1 | 11 |   1 |  1 | 111
   2 |  2 | 22 |   2 |  2 | 222
   3 |  3 |    |   3 |  3 | 333
   4 |  4 | 44 |     |    |    
   5 |  5 |    |     |    |    
(5 rows)

--Testcase 300:
DROP USER MAPPING FOR public SERVER mongo_server;
--Testcase 301:
DROP EXTENSION mongo_fdw CASCADE;
NOTICE:  drop cascades to 31 other objects
DETAIL:  drop cascades to server mongo_server
drop cascades to foreign table j1_tbl
drop cascades to foreign table j2_tbl
drop cascades to foreign table tenk1
drop cascades to foreign table tenk2
drop cascades to foreign table int4_tbl
drop cascades to foreign table t1
drop cascades to foreign table t2
drop cascades to foreign table t3
drop cascades to foreign table x
drop cascades to foreign table y
drop cascades to foreign table int8_tbl
drop cascades to foreign table tt1
drop cascades to foreign table tt2
drop cascades to foreign table tt3
drop cascades to foreign table tt4
drop cascades to foreign table xx
drop cascades to foreign table yy
drop cascades to foreign table zt1
drop cascades to view zv1
drop cascades to foreign table zt2
drop cascades to foreign table zt3
drop cascades to foreign table nt1
drop cascades to foreign table nt2
drop cascades to foreign table nt3
drop cascades to foreign table q1
drop cascades to foreign table q2
drop cascades to foreign table text_tbl
drop cascades to foreign table parent
drop cascades to foreign table child
drop cascades to foreign table int2_tbl
